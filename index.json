[{"categories":["KakaoTechBootCamp","Linux"],"content":" 리눅스에 대해 배웠다. 오늘은 실습이 주를 이뤘다. 각각의 명령어가 무슨 일을 하는지 모르다 보니 사실상 한컴타자연습 느낌.. 이렇구나 하고 넘어가는 정도라 다시 정리…! ","date":"2024-07-08","objectID":"/linux%E1%84%89%E1%85%B5%E1%86%B7%E1%84%92%E1%85%AA/:0:0","tags":["KakaoTechBootCamp","리눅스","CGroup","NameSpace","Chroot","UDS","OverlayFS"],"title":"Linux 심화","uri":"/linux%E1%84%89%E1%85%B5%E1%86%B7%E1%84%92%E1%85%AA/"},{"categories":["KakaoTechBootCamp","Linux"],"content":"CGroup(Control Group) 개념 프로세서가 사용하는 자원(CPU, 메모리, 디스크, I/O, 네트워크 대역폭 등) 관리 및 제한 애플리케이션의 성능 최적화 및 제어 프로세스를 그룹으로 묶고 사용할 수 있는 자원을 제한, 제어하는 방식 주요 기능 리소스 제한 : 자원을 제한해 안정성 보장 리소스 우선순위 : 중요도에 따른 자원을 할당 및 제한 리소스 계정 : 그룹 별 자원 사용량 모니터링 및 통계 정보 제공 리소스 격리 : 다른 프로세서 그룹 간의 자원 사용을 격리하여 타 그룹에 영향이 미치지 않도록 함 구조 cpu : 사용량 제한 및 보장 cpuacct : 사용량 모니터링 memory : 사용량 제한 및 통계 제공 blkio : 블록(디스크) I/O 사용량 제한 및 모니터링 net_cls : 네트워크 트래픽 분류 및 제한 freezer: 프로세스 중단, 재개 devices: 장치 접근 제어 hugetlb: 큰 페이지 메모리 사용량 제한 perf_event: 성능 이벤트 모니터링 사용법 # cgroup 실습 환경 세팅 sudo apt-get install cgroup-tools-stress # cpu 제한 실습 # cpulimit이라는 이름으로 cgroup 생성 sudo cgcreate -g cpu:/cpulimit # 생성 여부 확인 lscgroup | grep cpulimit # cpu 제한 설정(50000을 출력 후 출력 값을 cpu.max 파일에 기록) echo 50000 | sudo tee /sys/fs/cgroup/cpulimit/cpu.max # cpu 실행(cgroup의 cpu 서브시스템을 사용하는데 stress 도구를 사용해 부하를 준다) # cpulitmit을 실행하는데 cpu는 2개 vm(메모리 작업)은 1개를 작업 시작하고 30초 후 작업 종료 이 과정을 백그라운드에서 실행하고 작업 상태를 실시간으로 보여줘 sudo cgexec -g cpu:/cpulimit stress --cpu 2 --vm 1 --timeout 30s \u0026 top # cgroup 삭제 sudo cgdelete -g cpu:/cpulimit # memory 제한 실습 # memorylimit 이름의 그룹 생성 sudo cgcreate -g memory:/memorylimit # 512MB로 메모리 제한 설정 echo $((512 * 1024 * 1024)) | sudo tee /sys/fs/cgroup/memorylimit/memory.max # 메모리 시스템 부하 주기 및 0.5초 마다 memory.current 파일 내용 출력 sudo eegexec -g memory:/memorylimit stress --vm-byte 1024M --vm 1 --timeout 30s \u0026 watch -n 0.5 cat /sys/fs/cgroup/memorylimit/memory.current # cgroup 삭제 sudo cgdelete -g memory:/memorylimit ","date":"2024-07-08","objectID":"/linux%E1%84%89%E1%85%B5%E1%86%B7%E1%84%92%E1%85%AA/:1:0","tags":["KakaoTechBootCamp","리눅스","CGroup","NameSpace","Chroot","UDS","OverlayFS"],"title":"Linux 심화","uri":"/linux%E1%84%89%E1%85%B5%E1%86%B7%E1%84%92%E1%85%AA/"},{"categories":["KakaoTechBootCamp","Linux"],"content":"NameSpace 개념 프로세스가 시스템 리소스를 격리하여 독립된 환경에서 실행되도록 하는 기술 컨테이너 기술에서 중요하게 사용 종류 Mount Namespace : 파일 시스템 마운트를 격리하여 각각 독립적인 파일 시스템 트리를 갖고 있다. Process ID Namespace : 프로세스 ID 격리하고 독립된 프로세스 ID 공간을 가지므로, 네임스페이스 마다 동일한 PID를 가질수 있다. Network Namespace(net) : 네트워크 장치, IP 주소, 포트 번호 등을 격리하여 독립적인 네트워크 스택을 가지며 네임스페이스 간 장치를 독립적으로 사용 가능 User Namespace : 사용자와 그룹 ID를 격리하여 비루트 사용자가 네임스페이스 내에 루트 권한을 가질수 있다. IPC Namespace(ipc) : 프로세스간 통신(메시지, 큐, 세마포어, 공유 메모리 등)을 격리하여 타 네임스페이스와 충돌 없이 사용 가능하다. UTS Namespace(uts) : 호스트와 도메인 이름을 격리하여 독립적으로 사용 가능, 이는 컨테이너화 된 시스템 식별 정보를 별도 설정하기 유용하다. 사용법 # Namespace 실습 환경 세팅 sudo apt-get update sudo apt-get install -y util-linux # 새 마운트 네임스페이스 에서 관리자 권한으로 새로운 bash 셸 실행 sudo unshare --mount /bin/bash # 셸 안에 /mnt/test 디렉토리 생성 mkdir /mnt/test # tmpfs 타임의 임시 파일 시스템을 /mnt/test 에 마운트(운영체제에서 파일 시스템을 특정 디렉토리에 연결하여 사용할 수있도록 하는 과정) mount -t tmpfs none /mnt/test # \"Hello from Mount Namespace\"라는 텍스트를 /mnt/test/hello.txt 파일에 작성 echo \"Hello from Mount Namespace\" \u003e /mnt/test/hello.txt # 방금 작성 hello.txt의 내용 출력 cat /mnt/test/hello.txt # 새롭게 만든 마운트 네임스페이스(현재 셸) 종료 exit # 호스트 네임스페이스에서 /mnt/test 디렉토리의 내용 나열 ls /mnt/test # PID Namespace 실습 # PID 네임 스페이스 생성 sudo unshare -pid -fork /bin/bash # 생성된 PID 네임 스페이스 안에 실행 중인 모든 프로세스 출력 ps -none # 현재 bash 쉘의 프로세스 id 출력 echo $$ #PID 네임 스페이스 bash 쉘 종료 exit # 기존 PID 네임스페이스로 위 동작과 동일 ps -e echo $$ # User(UID, GID) Namespace 실습 # USER 네임 스페이스 생성 sudo unshare --user /bin/bash # 현재 id 정보 출력 id # root_test_file이라는 이름으로 빈 파일 생성 touch /root_test_file # 생성한 빈 파일 정보 출력 및 나가기 ls -l /root_test_file exit # 관리자 권한으로 root_test_file 삭제 sudo rm /root_test_file # UTS Namespace # 현재 시스템 호스트명 출력 hostname # 새로운 UTS 네임스페이스 생성 후 bash 쉘 실행 sudo unshare --uts /bin/bash # 새로운 UTS 안에 호스트 명을 kakao로 변경 후 출력 후 나가기 hostname kakao hostname exit # 기존 호스트 네임 출력 hostname ","date":"2024-07-08","objectID":"/linux%E1%84%89%E1%85%B5%E1%86%B7%E1%84%92%E1%85%AA/:2:0","tags":["KakaoTechBootCamp","리눅스","CGroup","NameSpace","Chroot","UDS","OverlayFS"],"title":"Linux 심화","uri":"/linux%E1%84%89%E1%85%B5%E1%86%B7%E1%84%92%E1%85%AA/"},{"categories":["KakaoTechBootCamp","Linux"],"content":"Chroot(Change Root) 개념 특정 디렉토리를 시스템의 루트 디렉토리로 설정하여 그 안에서 실행되는 프로그램이 해당 디렉토리를 루트로 인식(chroot jail) 시스템 일부를 격리하여 제한된 환경에서 테스트나 보안 목적으로 사용 특정 디렉토리를 빠져나가지 못하기 때문에 감옥 이라고도 부른다. 주요 기능 보안 : 사용자가 시스템의 다른 부분에 접근하지 못하도록 한다. 테스트 : 새로운 소프트웨어나 설정을 격리된 환경에서 테스트 사용법 # /mychroot 디렉토리 아래에 여러 디렉토리를 한번에 생성 sudo mkdir -p /mychroot/{bin,lib,lib64,dev,etc,proc,sys} # /bin 디렉토리의 모든 파일과 /bin/bash, /bin/ls, /bin/cat이 의존하는 모든 라이브러리 파일을 디렉토리 구조를 유지한 채 /mychroot로 복사 sudo cp /bin/* /mychroot/bin/ for lib in $(ldd /bin/bash /bin/ls /bin/cat | grep -o '/lib[^ ]*'); do sudo cp --parents \"$lib\" /mychroot; done # mychroot 환경에서 proc, sys, dev를 사용할 수 있도록 마운트 하는 작업을 수행한다. sudo mount -t proc proc /mychroot/proc sudo mount -t sysfs sys /mychroot/sys sudo mount --bind /dev /mychroot/dev # mychroot 디렉토리로 변경하고 쉘을 실행해 root 인 것처럼 동작하게 하는 작업 sudo chroot /mychroot /bin/bash # 현재 루트 디렉토리의 내용 나열 ls / # /etc/kakao에 파일 저장 후 출력 및 쉘 종료 echo \"Hello from chroot\" \u003e /etc/kakao cat /etc/kakao exit # 마운트한 proc, sys, dev를 언마운트 한 후 mychroot 디렉토리 및 하위 모든 내용 삭제 sudo umount /mychroot/proc sudo umount /mychroot/sys sudo umount /mychroot/dev sudo rm -rf /mychroot ","date":"2024-07-08","objectID":"/linux%E1%84%89%E1%85%B5%E1%86%B7%E1%84%92%E1%85%AA/:3:0","tags":["KakaoTechBootCamp","리눅스","CGroup","NameSpace","Chroot","UDS","OverlayFS"],"title":"Linux 심화","uri":"/linux%E1%84%89%E1%85%B5%E1%86%B7%E1%84%92%E1%85%AA/"},{"categories":["KakaoTechBootCamp","Linux"],"content":"UDS(Unix Domain Socket) 개념 동일한 컴퓨터 내의 프로세스 간 통신(Inter-Process Communication, IPC)를 위한 매커니즘 중 하나 TCP/IP 네트워크 소켓과 유사하지만 로컬 파일 시스템을 통해 통신 주요 특징 로컬 통신 : 호스트 내에세 실행되는 프로세스 간의 통신을 지원해 네트워크 소켓에 비해 성능 우수 파일 시스템을 이용한 주소 지정 : 파일 시스템 경로를 사용해 소켓을 식별하며 /tmp/mysocket과 같은 파일 경로 사용 데이터 전송 속도 : 네트워크 계층을 거치지 않아 빠른 데이터 전송 가능(네트워크 스택의 오버헤드를 줄이기 때문) 보안 : 파일 시스템 권한 설정을 통해 접근 제어, 특정 사용자나 프로세스만 소켓에 접근하도록 제한 사용법 # file name : server.py import socket import os SOCKET_FILE = \"/tmp/mysocket\" if os.path.exists(SOCKET_FILE): os.remove(SOCKET_FILE) server = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM) server.bind(SOCKET_FILE) server.listen(1) print(\"서버가 클라이언트를 기다리고 있습니다...\") conn, addr = server.accept() print(\"클라이언트 연결 수락\") while True: data = conn.recv(1024) if not data: break print(\"클라이언트로부터 받은 데이터:\", data.decode()) conn.sendall(data) conn.close() # file name : client.py import socket SOCKET_FILE = \"/tmp/mysocket\" client = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM) client.connect(SOCKET_FILE) message = \"안녕하세요, 서버!\" client.sendall(message.encode()) data = client.recv(1024) print(\"서버로부터 받은 데이터:\", data.decode()) client.close() # 하나의 터미널에서 작업 시 python3 server.py \u0026 python3 client.py ","date":"2024-07-08","objectID":"/linux%E1%84%89%E1%85%B5%E1%86%B7%E1%84%92%E1%85%AA/:4:0","tags":["KakaoTechBootCamp","리눅스","CGroup","NameSpace","Chroot","UDS","OverlayFS"],"title":"Linux 심화","uri":"/linux%E1%84%89%E1%85%B5%E1%86%B7%E1%84%92%E1%85%AA/"},{"categories":["KakaoTechBootCamp","Linux"],"content":"OverlayFS 개념 여러 디렉토리를 하나의 계층적 파일 시스템으로 병합 후 제공 읽기 전용 파일 시스템에 쓰기 가능한 레이어를 추가해 기본 파일 시스템을 변경 없이 수정, 추가 가능 주요 특징 파일 시스템 계층화 : 읽기 전용 및 쓰기 가능한 계층을 병합 후 사용 스냅샷 및 버전관리 : 파일 시스템의 상태를 스냅샷으로 저장 필요 시 복원 컨테이너 : Docker와 같은 컨테이너 기술에서 이미지 레이어링을 위해 사용 구조 Lowerdir : 읽기 전용 파일 시스템 Upperdir : 쓰기 전용 파일 시스템 Workdir : Lowerdir과 Upperdir의 변경사항 추적을 위한 디렉토리, Docker에서 해당 디렉토리가 없으면 동작x Merged : Lowerdir과 Upperdir을 합쳐서 만든 현재 상태의 파일 시스템 디렉토리 작동방식 새로운 파일 생성 : Upperdir에 파일 생성 기존 파일 읽기 : 파일이 Upperdir에 있으면 Upperdir에서 읽고 없으면 Lowerdir에서 읽음 기존 파일 수정 : 파일이 Upperdir에 없으면 Lowerdir에서 Upperdir로 복사 후 수정 파일 삭제 : 파일이 Upperdir에 있으면 삭제, Lowerdir에 있으면 Upperdir에 삭제 마커 생성 사용법 sudo mkdir -p /lower /upper /work /merged # /lower, /upper, /work, /merged 디렉토리를 생성합니다. (필요시 부모 디렉토리도 함께 생성) echo \"Lowerdir 입니다\" | sudo tee /lower/lowerfile.txt # \"Lowerdir 입니다\"라는 문자열을 /lower/lowerfile.txt 파일에 씁니다. (파일이 없으면 생성) echo \"Upperdir 입니다\" | sudo tee /upper/upperfile.txt # \"Upperdir 입니다\"라는 문자열을 /upper/upperfile.txt 파일에 씁니다. (파일이 없으면 생성) sudo mount -t overlay overlay -o lowerdir=/lower,upperdir=/upper,workdir=/work /merged # lowerdir로 /lower, upperdir로 /upper, workdir로 /work를 사용하여 /merged에 overlay 파일 시스템을 마운트합니다. ls /merged # /merged 디렉토리의 내용을 나열합니다. # \u003e\u003e merged에서 lowerfile.txt와 upperfile.txt 확인 cat /merged/lowerfile.txt # /merged 디렉토리 안의 lowerfile.txt 파일의 내용을 출력합니다. cat /merged/upperfile.txt # /merged 디렉토리 안의 upperfile.txt 파일의 내용을 출력합니다. echo \"Mergeddir 입니다\" | sudo tee /merged/mergedfile.txt # \"Mergeddir 입니다\"라는 문자열을 /merged/mergedfile.txt 파일에 씁니다. (파일이 없으면 생성) ls /upper # /upper 디렉토리의 내용을 나열합니다. (mergedfile.txt가 여기에 나타납니다) sudo umount /merged # /merged 디렉토리에 마운트된 파일 시스템을 언마운트합니다. sudo rm -rf /lower /upper /merged /work # /lower, /upper, /merged, /work 디렉토리와 그 안의 모든 파일을 강제로 삭제합니다. ","date":"2024-07-08","objectID":"/linux%E1%84%89%E1%85%B5%E1%86%B7%E1%84%92%E1%85%AA/:5:0","tags":["KakaoTechBootCamp","리눅스","CGroup","NameSpace","Chroot","UDS","OverlayFS"],"title":"Linux 심화","uri":"/linux%E1%84%89%E1%85%B5%E1%86%B7%E1%84%92%E1%85%AA/"},{"categories":["KakaoTechBootCamp","Linux"],"content":" 리눅스에 대해 배웠다. 처음 알게된 명령어도 많았지만 하다보면 외워지겠지… 일단 정리정리.. ","date":"2024-07-05","objectID":"/linux%EA%B8%B0%EC%B4%88/:0:0","tags":["KakaoTechBootCamp","BootCamp","Linux","리눅스","기초"],"title":"Linux 기초","uri":"/linux%EA%B8%B0%EC%B4%88/"},{"categories":["KakaoTechBootCamp","Linux"],"content":"리눅스 유닉스 계열의 OS 중 하나로 전 세계적으로 널리 사용되고 있는 오픈 소스 소프트웨어이다. 다양한 시스템에서 동작하며 특히 서버, 데스크탑, 모바일 기기에서 사용 ","date":"2024-07-05","objectID":"/linux%EA%B8%B0%EC%B4%88/:1:0","tags":["KakaoTechBootCamp","BootCamp","Linux","리눅스","기초"],"title":"Linux 기초","uri":"/linux%EA%B8%B0%EC%B4%88/"},{"categories":["KakaoTechBootCamp","Linux"],"content":"오픈소스 개념 오픈 소스 소프트웨어(OOS : Open Source Software)로 누구나 열람, 수정, 배포가 가능한 소프트웨어이다. 중요성 투명성 : 공개 소스로 동작 방식 확인 가능 협업과 혁신 : 누구나 수정, 배포가 가능해 빠른 소프트웨어 개선 비용 절감 : 라이센스 비용이 없거나 저렴함 자유와 통제 : 자유롭게 수정할 수 있는 권한 ","date":"2024-07-05","objectID":"/linux%EA%B8%B0%EC%B4%88/:2:0","tags":["KakaoTechBootCamp","BootCamp","Linux","리눅스","기초"],"title":"Linux 기초","uri":"/linux%EA%B8%B0%EC%B4%88/"},{"categories":["KakaoTechBootCamp","Linux"],"content":"GPL License 자유 소프트웨어 재단에서 만든 라이선스로 자유롭게 사용할 수 있고 수정, 배포 할 수 있는 권리 보장 ","date":"2024-07-05","objectID":"/linux%EA%B8%B0%EC%B4%88/:3:0","tags":["KakaoTechBootCamp","BootCamp","Linux","리눅스","기초"],"title":"Linux 기초","uri":"/linux%EA%B8%B0%EC%B4%88/"},{"categories":["KakaoTechBootCamp","Linux"],"content":"자유 소프트웨어 운동 사용, 수정, 공유의 자유를 보장하는 소프트웨어 소프트웨어는 사용자의 자유와 권리를 침해하지 않아야 한다는 철학 자유와 접근성을 증진하고 독점 소프트웨어에 대한 대안을 제공 ","date":"2024-07-05","objectID":"/linux%EA%B8%B0%EC%B4%88/:4:0","tags":["KakaoTechBootCamp","BootCamp","Linux","리눅스","기초"],"title":"Linux 기초","uri":"/linux%EA%B8%B0%EC%B4%88/"},{"categories":["KakaoTechBootCamp","Linux"],"content":"리눅스 구조 어플리케이션 사용자가 직접 상호작용하는 단계로 빌드된 앱, 바이너리, 명령어, 빌드된 파일을 통틀어 어플리케이션이라고 한다. 주요 기능 사용자가 상호작용할 수 있는 인터페이스 제공 커널을 통한 시스템 리소스(CPU, Memory, I/O 장치 등)을 사용 쉘 어플리케이션이 커널에서 사용하는 명령어를 가려주고 쉘을 사용해 스크립트도 만들 수 있다. 주요 기능 명령어 해석 : 사용자가 입력한 명령어 해석, 실행하기 위해 시스템 콜 스크립트 실행 : 쉘 스크립트를 통해 여러 명령어 조합이나 여러 명령어를 일괄 실행 환경 관리 : 환경 변수 설정 및 관리 커널 OS의 핵심 부분으로 하드웨어와 상호작용하는 단계 주요 기능 프로세스 관리 : 프로세스 생성, 스케줄링, 종료 등을 관리 메모리 관리 : 가상 메모리, 페이징, 스왑 메모리등을 통해 효율적인 메모리 관리 가상 메모리 : 보조기억장치를 이용해 실제 사용 가능한 메모리보다 더 많은 메모리를 사용가능하게 하는 기법 페이징 : 메모리를 좀 더 효율적으로 사용하기 위해 고안된 기법으로 메모리를 일정 크기만큼 잘라서 사용하는 기법 스왑 메모리 : 실제로 사용하지 않는 나머지 부분(페이지)을 보조기억장치의 특정 영역(스왑 영역)으로 옮겨서 공간을 확보하는 기법 파일 시스템 관리 : 파일의 저장, 접근, 조작을 지원하는 파일 시스템 관리 장치 관리 : 하드웨어 장치와의 상호작용을 관리하고 장치 드라이버를 통한 추상화 보안및접근제어 : 사용자와 시스템 자원 간의 보안정책을 관리하고 적용 하드웨어 물리적인 컴퓨터 구성요소로 CPU, Memory, SSD, HDD, Network Interface 등 직접 통제하지 않고 커널의 추상화를 통해 관리할 수 있도록 간접적으로 접근 주요 기능 CPU: 명령어 처리 및 프로그램을 실행 Memory: 실행 중인 프로그램과 데이터를 저장 저장 장치: 데이터를 (반)영구적으로 저장 ","date":"2024-07-05","objectID":"/linux%EA%B8%B0%EC%B4%88/:5:0","tags":["KakaoTechBootCamp","BootCamp","Linux","리눅스","기초"],"title":"Linux 기초","uri":"/linux%EA%B8%B0%EC%B4%88/"},{"categories":["KakaoTechBootCamp","Linux"],"content":"대표적인 Linux 배포판 Ubuntu Debian 계열중에 가장 유명한 배포판 쉬운 설계 및 직관적인 GUI 제공 방대한 레퍼런스 2년 단위의 버전 출시 및 5년간 유지보수로 보안성이 강하고 안정적 CentOS RHEL(RedHat Enterprise Linux)계열로 안정성과 보안이 뛰어나 주로 기업에서 많이 사용하는 OS 방대한 레퍼런스 CentOS 7까지는 무료였으나 CentOS 8부터는 유료로 제공 Arch Linux 경량화, 커스터마이징에 특화된 OS 자체 용량이 굉장히 작다. ","date":"2024-07-05","objectID":"/linux%EA%B8%B0%EC%B4%88/:6:0","tags":["KakaoTechBootCamp","BootCamp","Linux","리눅스","기초"],"title":"Linux 기초","uri":"/linux%EA%B8%B0%EC%B4%88/"},{"categories":["KakaoTechBootCamp","Linux"],"content":"패키지 매니저 APT Demian 계열에서 주로 사용하는 패키지 매니저 Demian : 여러 파생 배포판의 기반(Ex : Ubuntu, Linux Mint 등) 패키지 설치 시 의존성 패키지도 자동 설치 YUM/DNF RHEL 계열에서 주로 사용하는 패키지 RHEL(Red Hat Enterprise Linux) : 레드햇이 개발한 상용 리눅스 배포판, 주로 기업환경에서 사용되며 고성능, 안정성, 보안, 지원 서비스 제공 플러그인 시스템을 통해 기능 확장 가능 YUM보다 DNF를 사용하는 추세 ","date":"2024-07-05","objectID":"/linux%EA%B8%B0%EC%B4%88/:7:0","tags":["KakaoTechBootCamp","BootCamp","Linux","리눅스","기초"],"title":"Linux 기초","uri":"/linux%EA%B8%B0%EC%B4%88/"},{"categories":["KakaoTechBootCamp","Linux"],"content":"패키지 매니저 APT Demian 계열에서 주로 사용하는 패키지 매니저 Demian : 여러 파생 배포판의 기반(Ex : Ubuntu, Linux Mint 등) 패키지 설치 시 의존성 패키지도 자동 설치 YUM/DNF RHEL 계열에서 주로 사용하는 패키지 RHEL(Red Hat Enterprise Linux) : 레드햇이 개발한 상용 리눅스 배포판, 주로 기업환경에서 사용되며 고성능, 안정성, 보안, 지원 서비스 제공 플러그인 시스템을 통해 기능 확장 가능 YUM보다 DNF를 사용하는 추세 ","date":"2024-07-05","objectID":"/linux%EA%B8%B0%EC%B4%88/:8:0","tags":["KakaoTechBootCamp","BootCamp","Linux","리눅스","기초"],"title":"Linux 기초","uri":"/linux%EA%B8%B0%EC%B4%88/"},{"categories":["KakaoTechBootCamp","Linux"],"content":"권한 및 소유자 모든 파일 및 디렉토리는 사용자(User)와 그룹(Group)에 의해 소유(Ex : colton:KTB 라면 colton과 KTB에 속한 그룹의 소유) 사용자와 그룹 말고도 접근 권한을 지정 할 수 있다. R(Read) : 읽기 권한, cat으로 파일 내용 확인 가능 W(Write) : 쓰기 권한, vim, echo, sed 명령어 등으로 수정 가능 X(eXecute) : 실행 권한, sh, bash에 의해 실행될 수 있음 파일의 부여할 수 있는 권한은 Bit로 관리되며 Read 4, Write 2, Execute 1로 설정 한 파일이 갖는 모든 권한은 User, Group, Others(Ex : 754 라면 유저는 모든 권한, 그룹은 읽기 및 실행, 그 외는 읽기의 권한) ","date":"2024-07-05","objectID":"/linux%EA%B8%B0%EC%B4%88/:9:0","tags":["KakaoTechBootCamp","BootCamp","Linux","리눅스","기초"],"title":"Linux 기초","uri":"/linux%EA%B8%B0%EC%B4%88/"},{"categories":["KakaoTechBootCamp","Linux"],"content":"디렉토리 구조 Root Directory(/) : 시스템의 모든 디렉토리는 루트 하위에서 관리 bin(/bin) : 사용자 명령어가 저장되는 디렉토리(ls, cd, mv, rm, bash 등) lib(/lib) : 시스템, 어플리케이션의 공유 라이브러리가 저장 usr(/usr) : 앞서 설명한 디렉토리들이 모두 포함(앞선 디렉토리가 바라보고 있음) dev(/dev) : 장치 파일들이 저장되는 디렉토리(터미널, 널 장치 등 포함), 모든 장치가 파일 형태로 표시 etc(/etc) : 전반적인 시스템 설정 파일이 저장, 사용자 계정 정보, 암호정보, 호스트 네임/IP 매핑 파일 등 opt(/opt) : CLI 보다 GUI에서 자주 사용되는 디렉토리, 설치 매니저를 통해 설치된 어플리케이션이 주로 포함 proc(/proc) : 커널과 프로세스에 대한 가상 파일 시스템 저장(/proc/cpuinfo : CPU 정보, /proc/meminfo : 메모리 정보), 시스템 상태와 커널 정보등을 제공하며 동적으로 생성되는 파일들로 구성 home(/home) : 개인 디렉토리가 저장되는 위치, 기본적으로 권한과 소유자가 해당 유저에 맞게 설정 root(/root) : root 계정의 홈 디렉토리 tmp(/tmp) : 삭제되어도 문제 없는 파일이나 디렉토리와 같은 임시파일을 저장하는 디렉토리 ","date":"2024-07-05","objectID":"/linux%EA%B8%B0%EC%B4%88/:10:0","tags":["KakaoTechBootCamp","BootCamp","Linux","리눅스","기초"],"title":"Linux 기초","uri":"/linux%EA%B8%B0%EC%B4%88/"},{"categories":["KakaoTechBootCamp","Linux"],"content":"명령어 정리 sudo : root(다른 사용자)의 명령 실행(sudo apt-get update) su : 사용자 변경(su {userName}) adduser : 사용자 추가(adduser {userName}) cat : 파일 내용 출력, 파일 연결 후 출력(cat {fileName}) usermod : 사용자 속성 변경(usermod -aG {groupName} {userName}) addgroup : 새로운 그룹 추가(addgroup {groupName}) vim : 강력한 텍스트 편집기(vim {fileName}) echo : 문자열 출력(echo “Hello world!”) cd(change Directory) : 디렉토리 변경(cd ..) chmod : 권한 변경(chmod {775 : 권한} {fileName}) ls -al(ll) : 자세한 내용을 포함한 목록 표시 ls : 디렉토리 내용 나열 mv : 파일, 디렉토리 이름 변경 혹은 이동(mv {temp2 : 기존이름} {temp : 바꿀 이름}) rm : 파일, 디렉토리 삭제(rm {fileName}) bash : bash 셀 실행 exit : 현재 스크립트 종료 passwd : 사용자 비밀번호 변경 shadow : /etc/shadow 파일에 저장된 암호화된 비밀번호 관리 hosts : /etc/hosts 파일 관리 apt-get : 데비안 기반 시스템에서 패키지 관리(apt-get {install : 동작} {fileName}) export : 셸 환경 변수 설정(export PATH=$PATH:{/new/path}) lsblk : 블록 장치 목록 표시 df -TH : 파일 시스템의 디스크 공간 사용량 표사 mkdir : 디렉토리 생성(mkdir {directoryName}) rmdir : 빈 디렉토리 삭제(rmdir {directoryName}) touch : 빈 파일 생성 or 기존 파일 타임 스탬프 변경(touch {fileName}) head : 파일의 처음 몇 줄 출력(head {fileName}) tail : 파일의 마지막 몇 줄 출력(tail {fileName}) pwd : 현재 경로 출력 whoami : 현재 사용자 이름 출력 top : 실시간 시스템 상태 모니터링 df -h : 디스크 사용량을 읽기 쉽게 표시 du -h : 디렉토리 사용량을 읽기 쉽게 표시(du -h {directoryName}) ping : 네트워크 연결 상태 체크(ping www.google.com) curl : 데이터 전송 및 가져오기(curl www.google.com) ifconfig : 네트워크 인터페이스 구성 표시 및 변경 ps : 현재 실행중인 프로세스 목록 표시 find : 파일 시스템에서 파일과 디렉토리 검색(find {path} -name {fileName}) service : 서비스 시작, 중지, 재시작, 상태 확인 등을 수행(service {serviceName} {start / stop / restart / status / –status-all}) ip addr : 네트워크 인터페이스와 IP 주소 관리 및 사용 ","date":"2024-07-05","objectID":"/linux%EA%B8%B0%EC%B4%88/:11:0","tags":["KakaoTechBootCamp","BootCamp","Linux","리눅스","기초"],"title":"Linux 기초","uri":"/linux%EA%B8%B0%EC%B4%88/"},{"categories":["KakaoTechBootCamp","네트워크"],"content":" 네트워크에 대해 배웠는데 너무 모르겠다… 잘 따라 가려면 더욱 공부해야겠다.. ","date":"2024-07-04","objectID":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B0%9C%EB%85%90/:0:0","tags":["KakaoTechBootCamp","BootCamp","네트워크","네트워크 개념"],"title":"네트워크 개념","uri":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B0%9C%EB%85%90/"},{"categories":["KakaoTechBootCamp","네트워크"],"content":"네트워크 둘 이상의 컴퓨터와 연결하는 링크의 조합이다. 물리적 네트워크는 어댑터, 케이블 및 전화선과 같은 장비이고 소프트웨어 및 개념 모델이 논리적 네트워크를 형성한다. ","date":"2024-07-04","objectID":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B0%9C%EB%85%90/:1:0","tags":["KakaoTechBootCamp","BootCamp","네트워크","네트워크 개념"],"title":"네트워크 개념","uri":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B0%9C%EB%85%90/"},{"categories":["KakaoTechBootCamp","네트워크"],"content":"네트워크를 알아야 하는 이유 통신 및 데이터 교환(컴퓨터와 다른 장치들이 서로 통신하고 데이터를 교환할 수 있게 한다.) 분산 시스템 및 클라우드 컴퓨팅(여러 컴퓨터가 네트워크를 통해 하나의 시스템 처럼 작동, 대규모 데이터 처리 및 저장 분석 등) 해킹, 데이터유출 등 다양한 공격으로 부터 보호하기 위해 ","date":"2024-07-04","objectID":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B0%9C%EB%85%90/:2:0","tags":["KakaoTechBootCamp","BootCamp","네트워크","네트워크 개념"],"title":"네트워크 개념","uri":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B0%9C%EB%85%90/"},{"categories":["KakaoTechBootCamp","네트워크"],"content":"OSI 7 Layer, OSI 4 Layer OSI(Open System Interconnection : 개방형 시스템 상호 연결) : 다양한 통신 시스템이 통신 할 수 있도록 국제표준화기구에서 만든 개념 모델 OSI 7 Layer OSI 7 Layer 응용 프로그램 계층(Application) - 데이터 사용자 사용하는 응용프로그램과 인터페이스를 제공하는 계층 네트워크 서비스에 접근 할 수 있는 인터페이스 제공 주요 프로토콜 : HTTP, FTP, SMTP, DNS, Telnet, SSH등 주요 프로토콜 포트: FTP(20 : 전송, 21 : 제어), SSH(22), SMTP(25), DNS(53), HTTP(80), POP3(110), NTP(123), HTTPS(443) Application Layer 프레젠테이션 계층(Presentation) - 데이터 데이터 표현 방식 정의 및 압축, 암호화, 인코딩 수행 데이터 형식 변환, 암호화, 압축 기능 제공 주요 프로토콜 : JPEG, MPEG, ASCII Presentation Layer 세션 계층(Session) - 데이터 양 끝단의 애플리케이션 간의 대화 관리와 동기화를 담당 세션 설정, 유지, 종료 관리 및 데이터 동기화 보장 주요 프로토콜 : RPC, NetBIOS Session Layer 전송 계층(Transport) - 세그먼트 데이터 전송의 신뢰성과 흐름 제이를 담당 데이터 분할, 재조립, 오류 복구등을 처리 예 : TCP(Transmission Control Protocol), UDP(User Datagram Protocol 주요 프로토콜 : TCP, UDP, SCTP Transport Layer 네트워크 계층(Network) - 패킷 데이터를 목적지까지 전달하는 경로 선택 및 패킷 라우팅 라우팅, 패킷 전달, 트래픽 제어등을 수행 예 : 라이터, IP 주소 주요 프로토콜 : IP, ICMP, ARP, OSPF, BGP Network Layer 데이터 링크 계층(Data Link) - 프레임 물리 계층에서 받은 데이터를 프레임 형태로 만들어 네트워크 계층으로 전달 에러 검출, 흐름제어, 접근 제어 기능 수행 예: 이더넷 스위치, MAC 주소 주요 프로토콜 : Ethernet, PPP(Point-to-Point Protocol), HDLC, WI-FI Data Link Layer 물리 계층(Physical) - 비트 데이터 전송을 위한 물리적 매체를 이용해 비트 스트림, 전송하는 계층 전기적, 기계적, 기능적 틍성을 정의 및 데이터 송수신 담당 예: 케이블, 허브, 리피트 등 주요 프로토콜 : Ethernet, RS-232, USB 등 Physical Layer 7 Layer vs 4 Layer 단계가 많고 구조가 복잡해서 간단하고 인터넷 서비스에 적합한 4계층 모델이 개발됐다. 차이 ","date":"2024-07-04","objectID":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B0%9C%EB%85%90/:3:0","tags":["KakaoTechBootCamp","BootCamp","네트워크","네트워크 개념"],"title":"네트워크 개념","uri":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B0%9C%EB%85%90/"},{"categories":["KakaoTechBootCamp","네트워크"],"content":"계층별 장비 리피터(Repeater) 물리 계층 신호를 멀리 보내기 위한 증폭 장치 신호 감쇠 방지 및 전송 거리 증가 허브(Hub) 데이터 링크 계층 여러 장치를 하나의 네트워크로 연결시켜주는 장치 여러 컴퓨터 연결하지만 데이터 충돌 가능성이 있으며 Mac 주소를 인식하지 못한다. 브리지(Bridge) 데이터 링크 계층 두 개의 세그먼트를 연결 및 Mac 주소를 사용해 데이터 프레임 필터링 세그먼트 간의 트래픽 필터링 및 브로드캐스트 도메인 분할하려 충돌 감소 스위치 데이터 링크 계층 여러 장치를 연결하고 Mac 주소를 사용하여 프레임을 특정 포트로 전송 각 포트에 연결된 장치간 통신을 효율적으로 관리 및 충돌 도메인 분리해 성능 향상 라우터 네트워크 계층 다른 네트워크 간 데이터 전송, IP주소를 사용해 경로 결정 여러 네트워크를 연결해 데이터 패킷을 올바른 경로로 라우팅, 논리적 주소(IP 주소)를 기반으로 네트워크 트래픽 관리 ","date":"2024-07-04","objectID":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B0%9C%EB%85%90/:4:0","tags":["KakaoTechBootCamp","BootCamp","네트워크","네트워크 개념"],"title":"네트워크 개념","uri":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B0%9C%EB%85%90/"},{"categories":["KakaoTechBootCamp","네트워크"],"content":"주요 기술 Ethernet 가장 많이 사용되는 유선 네트워크, LAN(Local Area Network)에서 데이터 전송을 위해 사용 데이터를 프레임 단위로 나누어 전송(Mac 주소, 데이터 오류 검출 코드 등을 포함) IP(Internet Protocol) 네트워크에서 어떤 정보를 송수신하는 통신 규약, 호스트 주소를 지정 및 패킷 분할, 조립 기능 담당 특징 주소지정 : 고유한 IP 할당(IPv4, IPv6) 패킷 분할 및 재조립 : 큰 데이터 패킷을 분할 후 전송, 수신 측에서 재조립 경로 선택 : 패킷의 목적지까지 최적의 경로 선택 비연결형 : 패킷 전송 시 연결 설정 없이 독립적으로 전송 오류처리 : 패킷 전송 중 발생한 오류 처리 및 필요 시 재전송 생존시간 : 패킷의 수명을 설정해 네트워크가 무한정으로 떠돌지 않게함, 라우터를 거칠 때 마다 TTL 감소 프로토콜 식별 : 상위 계층 프로토콜 식별을 위해 헤더에 프로토콜 번호 포함 헤더 체크섬 : IP 헤더의 오류 검출을 위한 체크섬 필드 포함 패킷 형식 및 구조 : 헤더와 데이터로 구성되며 헤더는 목적지, 출발지 주소, TTL, 프로토콜 정보 등이 포함 IPv4 구조 실습(WireShark) IPv4 구성 및 헤더 32비트로 이루어져 있으며 최근 주소 부족으로 개별적으로 부여할 수 없다. IPv4 주소 부족 현상을 해결하기 위해 네트워크 클래스가 등장했다. 네트워크 클래스 A Class : 1.0.0.1 ~ 126.255.255.254 B Class : 128.0.0.1 ~ 191.255.255.254 C Class : 192.0.0.1 ~ 223.255.255.254 D Class : 224.0.0.0 ~ 239.255.255.255 E Class : 240.0.0.0 ~ 254.255.255.254 특수 용도 0.0.0.0/8 : 자체 네트워크 10.0.0.0/8 : 사설 네트워크 127.0.0.0/8 : 루프백(자기자신) 169.254.0.0/16 : 링크 로컬(link local) 172.16.0.0/12 : 사설 네트워크 192.0.2.0/24 : 예제 등 문서에서 사용 192.88.99.0/24 : 6to4 릴레이 애니캐스트 192.168.0.0/16 : 사설 네트워크 198.18.0.0/15 : 네트워크 장비 벤치마킹 테스트 224.0.0.0/4 : 멀티캐스트 240.0.0.0/4 : 미래 사용 용도로 예약 ","date":"2024-07-04","objectID":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B0%9C%EB%85%90/:5:0","tags":["KakaoTechBootCamp","BootCamp","네트워크","네트워크 개념"],"title":"네트워크 개념","uri":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B0%9C%EB%85%90/"},{"categories":["KakaoTechBootCamp","네트워크"],"content":"서브넷, 서브넷팅, 서브넷마스크 서브넷 IP 네트워크 보다 더 작은 네트워크 네트워크에 효율성을 높이고 쉽게 만들기 위해 사용, 분할로 인해 트래픽을 줄이고 보안을 강화 할 수 있다 서브넷팅 IP 주소 공간을 여러 개의 작은 서브넷으로 나누는 과정 서브넷마스크 IP에 네트워크와 호스트 부분을 구분하기 위해 사용되는 비트 패턴 ","date":"2024-07-04","objectID":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B0%9C%EB%85%90/:6:0","tags":["KakaoTechBootCamp","BootCamp","네트워크","네트워크 개념"],"title":"네트워크 개념","uri":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B0%9C%EB%85%90/"},{"categories":["KakaoTechBootCamp","네트워크"],"content":"전송 계층 TCP 인터넷 같은 네트워크에서 데이터를 신뢰성 있게 전송하기 위해 설계된 연결 지향형 프로토콜 구조 3-way handshak : TCP 연결 설정 과정(SYN -\u003e SYN-ACK -\u003e ACK) 흐름제어 : 데이터 전송 속도 조절, 수신자 버퍼 오버플로우 방지(슬라이딩 윈도우) 혼잡제어 : 네트워크 혼잡 방지 및 해결, 패킷 손실과 지연 방지 UDP 데이터를 빠르고 효율적으로 전송하기 위해 설계된 비연결형 프로토콜 전송 순서와 신뢰성은 보장되지 않지만 속도와 효율성이 필요한 부분에 적합(ex : 실시간 스트리밍) 구조 데이터그램 : 비연결형 데이터 전송 단위, 순서 보장 x 스트리밍 : 실시간 연속 데이터 전송 방식, 주로 멀티 콘텐츠에 이용 ","date":"2024-07-04","objectID":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B0%9C%EB%85%90/:7:0","tags":["KakaoTechBootCamp","BootCamp","네트워크","네트워크 개념"],"title":"네트워크 개념","uri":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B0%9C%EB%85%90/"},{"categories":["KakaoTechBootCamp","네트워크"],"content":"HTTP, HTTPs 서버/클라이언트 모델에 따라 데이터를 주고 받기 위한 프로토콜, TCP/IP 위에서 동작 연결 상태를 유지하지는 않는다.(비연결형) -\u003e 요청/응답 방식으로 동작, Cookie와 Session의 등장으로 비연결성, 비상태성 보완 암호화되지 않기 때문에 보안에 취약하다. HTTP Response : 200, 404, 500 등 ","date":"2024-07-04","objectID":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B0%9C%EB%85%90/:8:0","tags":["KakaoTechBootCamp","BootCamp","네트워크","네트워크 개념"],"title":"네트워크 개념","uri":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B0%9C%EB%85%90/"},{"categories":["KakaoTechBootCamp","네트워크"],"content":"캡슐화 동작 방식 ","date":"2024-07-04","objectID":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B0%9C%EB%85%90/:9:0","tags":["KakaoTechBootCamp","BootCamp","네트워크","네트워크 개념"],"title":"네트워크 개념","uri":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B0%9C%EB%85%90/"},{"categories":["KakaoTechBootCamp","네트워크"],"content":"네트워크 용어 정리 LAN(근거리 통신망) : 허브, 스위치로 연결하는 소큐모 네트워크, 주로 컴퓨터 장치와 연결된 네트워크를 말한다. MAN(대도시 통신망) : 도시와 도시의 통신망을 뜻하며 2개 이상의 LAN을 라우터, 브릿지로 연결, 고속 데이터 전송을 지원하며 통신사나 공공기관에서 운영한다. WAN(국가간 통신망) : 광역 네트워크로 지리적으로 넓은 영역에 걸쳐 여러 LAN, MAN을 연결하는 네트워크, 주로 Internet이라고 한다. WLAN(무선 근거리 통신망) : 라디오, 마이크로파(무선 랜 카드 등)를 이용해 데이터를 전송 VPN(사설 통신망) : 가상 사설망으로 공중 네트워크를 암호화된 방법으로 접속할 수 있는 기술 IP(Internet Protocol) : 인터넷을 통하는 네트워크에서 정보를 송수신하는 통신 규약 라우터 : 둘 이상의 패킷 전환 네트워크 또는 서브네트워크를 연결하는 장치, 네트워크 계층에서 동작한다. 라우팅 : 다양한 네트워크 간에 데이터를 전송하는 역할, 네트워크에서 패킷을 받아 목적지까지 최적의 경로를 결정 후 데이터 전달 패킷 : 네트워크에서 출발지와 목적지간에 라우팅되는 데이터 단위 포트 : 소프트웨어 기반이며 OS에서 관리하는 네트워크 연결이 시작되고 끝나는 가상의 지점 네트워크 케이블 유형 : 이더넷 케이블, 광섬유 케이블 등 프로토콜 : 데이터 교환 방식을 정의하는 규칙 체계 CIDR : 데이터 라우팅 효율성을 향상시키는 IP주소 할당 방법 VPC : 퍼블릭 클라우드 환경에서 사용할 수 있는 고객 전용 사설 네트워크 NAT : Private IP 주소로 외부와 통신할 수 없어 Public IP 주소로 변환(Ex : 공유기) 루프백 : localhost로 알려져 있으며 자신의 ip 스택을 통해 네트워크 인터페이스로 전송된 데이터를 동일한 시스템으로 다시 전송 멀티캐스트 : 하나의 송신자가 여러 수신자에게 동시에 데이터를 전송하는 방식 주로 스트리밍, 주식 거래 등 대규모 수신자에게 동일한 데이터를 효율적으로 전달해야 하는 경우 포트포워딩 : 외부 네트워크에서 특정 포트로 들어오는 트래필을 내부 네트워크의 특정 IP 주소와 포트로 전달하는 네트워크 설정 보수표현법 : 컴퓨터에서 음수를 표현하는 데 사용하는 방법, 1의 보수는 반전(1010 -\u003e 0101), 2의 보수는 반전 후 1을 더함(1010 -\u003e 0110) ","date":"2024-07-04","objectID":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B0%9C%EB%85%90/:10:0","tags":["KakaoTechBootCamp","BootCamp","네트워크","네트워크 개념"],"title":"네트워크 개념","uri":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B0%9C%EB%85%90/"},{"categories":["KakaoTechBootCamp","네트워크"],"content":"포스트 작성 시 참고한 링크 네트워크 및 통신개념 ","date":"2024-07-04","objectID":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B0%9C%EB%85%90/:11:0","tags":["KakaoTechBootCamp","BootCamp","네트워크","네트워크 개념"],"title":"네트워크 개념","uri":"/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B0%9C%EB%85%90/"},{"categories":["KakaoTechBootCamp","클라우드"],"content":" 어제 어수선한 분위기 속에 첫날이 마무리되고 두번째 수업이 진행되었습니다. 오늘은 클라우드 개론에 대해 배웠고 까먹지 않기 위해 정리해보고자 합니다. ","date":"2024-07-03","objectID":"/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C%EA%B0%9C%EB%85%90/:0:0","tags":["KakaoTechBootCamp","BootCamp","클라우드개념","리소스","가상화"],"title":"클라우드 개념","uri":"/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C%EA%B0%9C%EB%85%90/"},{"categories":["KakaoTechBootCamp","클라우드"],"content":"클라우드 개념 컴퓨터 네트워크를 통해 인터넷 상에서 데이터 저장, 컴퓨팅 파워, 소프트웨어 등을 제공하는 기술이다. 즉, 인터넷 상에서 여러 리소스를 내가 원할 때 원하는 만큼 제공한다. ","date":"2024-07-03","objectID":"/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C%EA%B0%9C%EB%85%90/:1:0","tags":["KakaoTechBootCamp","BootCamp","클라우드개념","리소스","가상화"],"title":"클라우드 개념","uri":"/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C%EA%B0%9C%EB%85%90/"},{"categories":["KakaoTechBootCamp","클라우드"],"content":"리소스 제공 통째로 빌려주는 방법 쉬운 방법이나, 내가 원하는 리소스랑 다를 수 있다. 원하는 리소스가 8코어 16기가 인데 16코어 32기가 서버가 존재한 경우 오버스펙이 된다. 사용자가 원하는 만큼 서버를 띄우는 방법 통째로 빌려주는 것이 아닌 큰 서버에서 사용자가 원하는 만큼 서버를 만들어 제공한다. 이때 사용하는 기술이 가상화(Virtualization)이다. ","date":"2024-07-03","objectID":"/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C%EA%B0%9C%EB%85%90/:2:0","tags":["KakaoTechBootCamp","BootCamp","클라우드개념","리소스","가상화"],"title":"클라우드 개념","uri":"/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C%EA%B0%9C%EB%85%90/"},{"categories":["KakaoTechBootCamp","클라우드"],"content":"가상화(Virtualization) 개념 물리적인 자원을 추상화하여 가상 자원을 만들어 관리하는 기술이다.(Ex : 안드로이드 애뮬레이터 등) 방법 호스트 가상화 가장 쉬운 방법, window 혹은 mac에서 가상화 소프트웨어를 이용하여 서버를 만드는 방법이다.(Ex : Virtual Box, VMware Fusion 등) 호스트 가상화 하이퍼바이저 가상화 하드웨어에 하이퍼바이저를 설치하여 가상 자원을 만드는 방법이다.(Ex : Xen, KVM 등) OS 명령어를 하이퍼바이저가 모두 받아들이거나(Para-Virtualization, PV) 하드웨어에서 OS 명령어를 이해하는 경우(Hardware Virtual Machine, HVM / Bare-Metal Hypervisor)가 있다. 엔지니어가 주로 사용하는 방법이다. 호스트 가상화와 가장 큰 차이점은 OS 위에 다른 OS를 띄우는 호스트 가상화와 달리 하드웨어 위에 하이퍼바이저를 설치 후 그 위에 OS를 띄운다. 하이퍼바이저 가상화 컨테이너 가상화 컨테이너 관리 소프트웨어를 설치하여, 논리적으로 나누어 사용한다.(Ex : Docker, Linux Container 등) 컨테이너 가상화 ","date":"2024-07-03","objectID":"/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C%EA%B0%9C%EB%85%90/:3:0","tags":["KakaoTechBootCamp","BootCamp","클라우드개념","리소스","가상화"],"title":"클라우드 개념","uri":"/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C%EA%B0%9C%EB%85%90/"},{"categories":["KakaoTechBootCamp","클라우드"],"content":"AWS(Amazon Web Services)는 어떤 가상화를 사용할까? AWS EC2에서는 초반에 PV 방식을 사용하다가 HVM 방식을 사용하고 있으며, 최근 Nitro System을 사용하기 시작했다. AWS ECS에서는 컨테이너 가상화를 활용 중이다. ","date":"2024-07-03","objectID":"/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C%EA%B0%9C%EB%85%90/:4:0","tags":["KakaoTechBootCamp","BootCamp","클라우드개념","리소스","가상화"],"title":"클라우드 개념","uri":"/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C%EA%B0%9C%EB%85%90/"},{"categories":["KakaoTechBootCamp","클라우드"],"content":"가상화 종류 서버 가상화 하나의 물리적 서버를 여러 가상 서버로 분할하여 사용 데스크탑 가상화 사용자의 데스크탑 환경 가상화 애플리케이션 가상화 애플리케이션을 가상 환경에서 실행하여 운영 체제와 분리 네트워크 가상화 물리적 네트워크 자원을 가상화하여 여러 가상 네트워크 생성 스토리지 가상화 물리적 스토리지를 추상화하여 논리적 스토리지 풀 생성 ","date":"2024-07-03","objectID":"/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C%EA%B0%9C%EB%85%90/:5:0","tags":["KakaoTechBootCamp","BootCamp","클라우드개념","리소스","가상화"],"title":"클라우드 개념","uri":"/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C%EA%B0%9C%EB%85%90/"},{"categories":["KakaoTechBootCamp","클라우드"],"content":"Virtual Machine과 Bare Metal Virtual Machine(VM) 가상 머신. 가상화 방식(PV or HVM)기반의 서버 대부분의 클라우드 내 서버는 VM 방식 사용 Bare Metal(BM) 큰 서버에서 분할해 제공하는 VM 방식과 달리 통째로 서버를 제공해주는 방법 필요한 CPU, Memory, Storage 만큼 하드웨어를 만들어 전달 Virtual Machine vs Bare Metal VM은 같은 하드웨어 위에서 분할하여 사용하므로 한 사용자가 대량으로 리소스를 사용하면 하이퍼바이저에 영향이 가고 다른 사용자에게 까지 영향을 미칠수 있다. 따라서, 안정적으로 좋은 성능을 요구한다면 BM을 비용 절감을 요구한다면 VM을 사용을 추천한다. ","date":"2024-07-03","objectID":"/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C%EA%B0%9C%EB%85%90/:6:0","tags":["KakaoTechBootCamp","BootCamp","클라우드개념","리소스","가상화"],"title":"클라우드 개념","uri":"/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C%EA%B0%9C%EB%85%90/"},{"categories":["KakaoTechBootCamp","클라우드"],"content":"CPU와 vCPU CPU 실제 하드웨어 자원, 물리적인 서버에서 실제 연산 vCPU 가상화 환경에서 물리적 CPU 자원을 추상화한 자원, VM에 할당된 가상 자원 CPU vs vCPU 두 자원은 엄연히 다른 자원이다. ","date":"2024-07-03","objectID":"/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C%EA%B0%9C%EB%85%90/:7:0","tags":["KakaoTechBootCamp","BootCamp","클라우드개념","리소스","가상화"],"title":"클라우드 개념","uri":"/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C%EA%B0%9C%EB%85%90/"},{"categories":["KakaoTechBootCamp","클라우드"],"content":" 어제 어수선한 분위기 속에 첫날이 마무리되고 두번째 수업이 진행되었습니다. 오늘은 클라우드 개론에 대해 배웠고 까먹지 않기 위해 정리해보고자 합니다. ","date":"2024-07-03","objectID":"/%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%E1%84%8B%E1%85%AE%E1%84%83%E1%85%B3%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5/:0:0","tags":["KakaoTechBootCamp","BootCamp","클라우드아키텍처","아키텍처"],"title":"클라우드 아키텍처","uri":"/%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%E1%84%8B%E1%85%AE%E1%84%83%E1%85%B3%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5/"},{"categories":["KakaoTechBootCamp","클라우드"],"content":"클라우드 아키텍처 애플리케이션을 실행할 기반이 되는 온라인 플랫폼을 제공할 목적으로 클라우드 구축에 필수적인 모든 구성 요소 및 기능을 연결하는 방식 서비스를 구축할 때, 클라우드 서비스의 다양한 기능들을 이용하여 인프라 구축 그림을 그리는 것 ","date":"2024-07-03","objectID":"/%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%E1%84%8B%E1%85%AE%E1%84%83%E1%85%B3%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5/:1:0","tags":["KakaoTechBootCamp","BootCamp","클라우드아키텍처","아키텍처"],"title":"클라우드 아키텍처","uri":"/%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%E1%84%8B%E1%85%AE%E1%84%83%E1%85%B3%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5/"},{"categories":["KakaoTechBootCamp","클라우드"],"content":"클라우드 아키텍처를 그리기 위한 배경지식들 OS(Operating System) 하드웨어를 사용하기 위해 필요한 소프트웨어이다. Ex : Windows, Mac, Linux 등 파일시스템 운영 체제에서 HD, SSD 또는 USB 플래시 드라이브와 같은 저장 장치에 있는 파일을 구성하고 관리하는 데 사용하는 구조이다. 클라우드에서도 서버 용량을 붙일 때 HD, SSD로 붙일지 선택하고 Network Block으로 만들어 붙인다. 따라서, VM에 있는 파일시스템 성능과 로컬에 성능은 다를 수 있다. NFS(Network File System), NBD(Network Block Device)와 같은 파일시스템에 대한 가상화도 많이 활용된다. VM (Virtual Machine) 가상화된 서버 보통 OnDemand 형태로 필요한 만큼 사용하거나 1년이나 3년 비용을 미리 할인되 가격으로 내는 Reserved 방식으로 활용한다 Spot Instance 형태로 저렴하게 사용 가능 단, 남는 리소스를 잠깐 빌려주는 형태라 강제로 서버가 회수될 수 있다. LB(Load Balancer) 네트워크 트래픽을 여러 서버로 분산시키는 역할 서버 이중화하는 경우 가장 많이 사용한다. 이중화를 통해 HA(고가용성)을 책임진다. HA : 바람직한 정도로 긴 시간동안 지속적으로 운영이 가능한 시스템이나 컴포넌트를 가리킨다. LB도 서비스 이기 때문에 느려질 수 있다. 트래픽 몰릴 것으로 예상되는 시점에 서버도 늘리지만, LB에 미리 부하를 줘서 LB를 구성하는 서버도 미리 늘려놓는다. Pre-Warming 또는 Warm-Up이라고 부릅니다. 데이터베이스 데이터를 저장하고 관리하는 서비스 라이센스 규정에 의해 비슷한 서비스를 자체적으로 만들어 공급하는 경우가 많다(Ex : DynamoDB) 오픈소스를 운영하는 경우도 있다(Ex : Amazon RDS for MySQL, Elasticache) AWS는 최신 버전을 업데이트 해주지만 많은 클라우스 서비스들이 버전업, 유지보수를 해주지 않는 경우가 많다. CDN (Content Delivery Network) 자주 바뀌지 않는 리소스들을 캐싱하여 데이터를 전달하는 서비스 서버에서 리소스를 전달하면, 그 만큼 서버의 트래픽이 나가는데 이 트래픽을 CDN이 대신 책임져준다면 서버의 부담이 낮아진다. 캐싱을 사용해 서버가 리소스를 전달하는 것보다 효율적이다. 따라서, 자주 바뀌지 않는 리소스를 올리는게 좋습니다. MSA (Micro Service Architecture) 작은 독립적인 서비스들로 분할하여 운영하는 아키텍처로 VM이나 Container를 이용하여 운영되어야 한다. 보통 VM에 직접 올리는 형태에서 VM에 Container를 올려 운영하다가, 최종적으로는 EKS와 같은 쿠버네티스 시스템을 활용하는 형태로 고도화됩니다. ","date":"2024-07-03","objectID":"/%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%E1%84%8B%E1%85%AE%E1%84%83%E1%85%B3%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5/:2:0","tags":["KakaoTechBootCamp","BootCamp","클라우드아키텍처","아키텍처"],"title":"클라우드 아키텍처","uri":"/%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%E1%84%8B%E1%85%AE%E1%84%83%E1%85%B3%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5/"},{"categories":["KakaoTechBootCamp","클라우드"],"content":"다층구조 소프트웨어 애플리케이션을 논리적으로 분리된 여러 계층으로 나누어 구성하는 아키텍처 스타일 다층 구조는 보통 프레젠테이션 계층(=프론트엔드 계층), 애플리케이션 계층(=백엔드 계층), 데이터 계층(=데이터베이스 계층)으로 나눈다.(고차원으로 갈수룩 더 다양한 계층이 생길 수 있다.) 다층 구조 종류 1티어 구조 프론트, 백, DB가 하나의 VM에서 돌고 있는 상황이다. VM이 죽는다면 모든 서버가 죽고 VM을 살리면 모든 서버를 살릴 수 있다. 2티어 구조 프론트, 백엔드 서버 구분 없이 하나의 서버에서 DB와 연결된 상황이다. 많이 사용되는 아키텍처, 안정성과 관리가 용이하다. 단점으로는 백엔드에서 나는 에러가 프론트에서도 난다.(Ex: 404페이지, 500페이지 등) 3티어 구조 프론트와 백엔드를 구별하고 백엔드에서 DB에 연결된 상황 인프라 운영 노하우가 있고 제품을 이해하고 있으면 가장 나은 방식이다. N티어 구조 백엔드에 역할을 다양하게 나누어 서로 API 통신하게 만드는 형태 대부분의 SaaS가 해당 형태로 운영된다. 다층구조 핵심 비즈니스 상황을 고려하여 티어를 선택 애플리케이션이 너무 커져서 모듈로 쪼갠다면 데이터 기반이 보편적이다.(결제 시스템, 유저 시스템 등) ","date":"2024-07-03","objectID":"/%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%E1%84%8B%E1%85%AE%E1%84%83%E1%85%B3%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5/:3:0","tags":["KakaoTechBootCamp","BootCamp","클라우드아키텍처","아키텍처"],"title":"클라우드 아키텍처","uri":"/%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%E1%84%8B%E1%85%AE%E1%84%83%E1%85%B3%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5/"},{"categories":["KakaoTechBootCamp","가상화"],"content":" 어제 어수선한 분위기 속에 첫날이 마무리되고 두번째 수업이 진행되었습니다. 오늘은 클라우드 개론에 대해 배웠고 까먹지 않기 위해 정리해보고자 합니다. ","date":"2024-07-03","objectID":"/%EA%B0%80%EC%83%81%ED%99%94%EA%B8%B0%EC%88%A0/:0:0","tags":["KakaoTechBootCamp","BootCamp","가상화기술","IaaS","PaaS","SaaS"],"title":"가상화 기술","uri":"/%EA%B0%80%EC%83%81%ED%99%94%EA%B8%B0%EC%88%A0/"},{"categories":["KakaoTechBootCamp","가상화"],"content":"가상화 기술 클라우드 서비스(IaaS : Infrastructure as a Service 혹은 CSP : Cloud Service Provider) 각종 자원들을 가상화하여 서비스 제공(서버, 네트워크, 스토리지 등) 기본 기능 : Compute, Network, Storage, Container, Database, Security, Ai 등 AWS, GCP, Kakao Cloud 등 플랫폼 기반 서비스(PaaS : Platform as a Service) 본인 애플리케이션을 쉽게 업로드하여 서비스 활용 가상화된 자원을 자동으로 할당받아 애플리케이션이 실행 Heroku, Vercel, Netlify, 카페24 등 솔루션 기반 서비스(SaaS : Software as a Service) 사용자의 니즈가 반영된 애플리케이션이 가상화된 자원을 할당받아 곧바로 서비스 제공 사용량에 따른 과금 정책이 대부분 구글 드라이브, 드롭박스, 네이버 MyBox등 대부분의 서비스가 여기에 속한다. 가상화 기술 ","date":"2024-07-03","objectID":"/%EA%B0%80%EC%83%81%ED%99%94%EA%B8%B0%EC%88%A0/:1:0","tags":["KakaoTechBootCamp","BootCamp","가상화기술","IaaS","PaaS","SaaS"],"title":"가상화 기술","uri":"/%EA%B0%80%EC%83%81%ED%99%94%EA%B8%B0%EC%88%A0/"},{"categories":["KakaoTechBootCamp","가상화"],"content":"집중적으로 공부해야하는 가상화 기술 대부분의 기업이 IaaS를 통해 SaaS를 출시한다. IaaS를 하는 기업은 대기업 위주이며(네이버 클라우드, 카카오 클라우드 등) 대부분의 클라우드는 IaaS를 이용해 SaaS를 개발한다. 클라우드 시장 보통 Iaas, PaaS, SaaS로 나누어 보고 IaaS 시장에서 가장 많이 사용되는 서비스는 현재 AWS다. IaaS를 만든다는 뜻 openStack 등의 솔루션을 통해 각 리소스를 가상화하고 서비스를 만드는것 여기에 흥미가 있다면 C/C++/Python 등을 공부하여 openStack을 활용해보는 것이 좋다. 다만, 현재로써는 석박사 과정이 필수이다. ","date":"2024-07-03","objectID":"/%EA%B0%80%EC%83%81%ED%99%94%EA%B8%B0%EC%88%A0/:2:0","tags":["KakaoTechBootCamp","BootCamp","가상화기술","IaaS","PaaS","SaaS"],"title":"가상화 기술","uri":"/%EA%B0%80%EC%83%81%ED%99%94%EA%B8%B0%EC%88%A0/"},{"categories":["KakaoTechBootCamp","가상화"],"content":"자주 사용하는 기능 가장 기본적으로 Network를 아용하여 네트워크 구조 세팅 세팅된 Network 위에 Compute를 이용한 서버 구축 Database를 이용한 애플리케이션 DB 연결 Storage를 이용하여 애플리케이션에서 나오는 로그와 같은 파일 저장 그 외로 Security를 통해 보안 강화, AI를 통해 AI 서비스 붙이기 즉, 이외에는 필요한 것들을 찾아 붙이는 방식 ","date":"2024-07-03","objectID":"/%EA%B0%80%EC%83%81%ED%99%94%EA%B8%B0%EC%88%A0/:3:0","tags":["KakaoTechBootCamp","BootCamp","가상화기술","IaaS","PaaS","SaaS"],"title":"가상화 기술","uri":"/%EA%B0%80%EC%83%81%ED%99%94%EA%B8%B0%EC%88%A0/"},{"categories":["KakaoTechBootCamp","클라우드"],"content":" 어제 OT를 잘 마치고 오늘 첫번째 수업 날 입니다! 오늘은 별다른 수업 없이 ZEP에 접속하고 노션(단체, 개인 목표를 작성)을 만들었습니다. 진도를 나가지 않아 엄청 어수선한 분위기 속에 어떻게 되련지…. 아침에 말씀해주셨던 부분 중 일부분을 찾아보고 작성하였습니다. ","date":"2024-07-02","objectID":"/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9Cot/:0:0","tags":["KakaoTechBootCamp","BootCamp","서버이중화","안정성vs효율성","쿠버네티스","클라우드경험"],"title":"부트캠프 시작(클라우드 OT)","uri":"/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9Cot/"},{"categories":["KakaoTechBootCamp","클라우드"],"content":"쿠버네티스 컨테이너화 된 애플리케이션의 자동화(Deploy, Scaling 등을 제공) 하는 시스템 쿠버네티스를 운영하기 위한 서버가 따로 필요하다. 항상 쿠버네티스가 솔루션인가는 고민해볼 필요가 있다. ","date":"2024-07-02","objectID":"/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9Cot/:1:0","tags":["KakaoTechBootCamp","BootCamp","서버이중화","안정성vs효율성","쿠버네티스","클라우드경험"],"title":"부트캠프 시작(클라우드 OT)","uri":"/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9Cot/"},{"categories":["KakaoTechBootCamp","클라우드"],"content":"서버의 이중화는 반드시 필요한가? 정답은 없는 부분이라 섣부르게 답변하기 어렵지만 내 생각을 정리하자면 반드시 필요하지는 않다고 생각한다. 주식, 게임과 같은 실시간 서비스거나 트래픽이 많은 대규모 어플리케이션을 운영하는 경우 필요하다고 생각하지만. 사내에서 인트라넷, 비즈니스에 큰 영향이 가지 않는 경우 이중화를 하게 되면 비용적인 문제가 발생할 수 있다고 생각한다. 따라서, 서비스의 특징과 상황을 고려하여 이중화를 진행해야 한다고 생각합니다. ","date":"2024-07-02","objectID":"/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9Cot/:2:0","tags":["KakaoTechBootCamp","BootCamp","서버이중화","안정성vs효율성","쿠버네티스","클라우드경험"],"title":"부트캠프 시작(클라우드 OT)","uri":"/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9Cot/"},{"categories":["KakaoTechBootCamp","클라우드"],"content":"안정성 vs 효율 개발자는 항상 기로에 놓이는 것 같습니다. 새로운 기술을 채택하여 효율적으로 작업하거나 기존의 기술을 채택하여 안정적으로 작업하거나 이것도 마찬가지로 정답은 없지만 그때그때 상황에 맞게 사용할 수 있도록 소통 및 판단하는 능력이 중요할 것 같습니다. ","date":"2024-07-02","objectID":"/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9Cot/:3:0","tags":["KakaoTechBootCamp","BootCamp","서버이중화","안정성vs효율성","쿠버네티스","클라우드경험"],"title":"부트캠프 시작(클라우드 OT)","uri":"/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9Cot/"},{"categories":["KakaoTechBootCamp","클라우드"],"content":"나한테 이득이 되는 경험 서비스 운영 도메인 붙인 서비스 리소스 모터링(스케일인 / 스케일아웃) 개인정보처리방침과 이용약관 이해하고 회원가입 데이터 관리 db를 클라우드에 깔기 백업 자동화 데이터베이스 관리 애플리케이션 보안 Token 기반으로 api가 동작하도록 만들어보기 가장 쉬운 방법 세션, 토큰, key(하드하게 넣으면 탈취 당할 수 있음, 파일을 따로 둔다.) api 파라미터를 조작하여 다른 계정의 데이터를 가져올 수 없게 만들기 주요 3rd Party Key들을 보관할 때. 하드코딩 말고 밖으로 배서 관리하기 Vault을 통해 관리하기 ","date":"2024-07-02","objectID":"/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9Cot/:4:0","tags":["KakaoTechBootCamp","BootCamp","서버이중화","안정성vs효율성","쿠버네티스","클라우드경험"],"title":"부트캠프 시작(클라우드 OT)","uri":"/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9Cot/"},{"categories":["KakaoTechBootCamp","클라우드"],"content":"클라우드 엔지니어가 알고 있으면 좋은 것들(추후에 포스트로 작성 예정) 쿠버네티스 네트워크 -\u003e 20240704 작성 리눅스 보안 장애 대응 프로세서 HA(고가용성) Absible Terraform 온프레미스 방식 ssh sre kisa MongoDB Atlas(몽고 디비를 클라우드 서비스로 제공) session token GIB ","date":"2024-07-02","objectID":"/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9Cot/:5:0","tags":["KakaoTechBootCamp","BootCamp","서버이중화","안정성vs효율성","쿠버네티스","클라우드경험"],"title":"부트캠프 시작(클라우드 OT)","uri":"/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9Cot/"},{"categories":["Java"],"content":" 커리어리라는 어플을 보다가 주니어 자바 개발자를 위한 100가지 질문을 보게 되었다. 오늘의 질문! String 클래스의 메서드는 무엇이 있을까? 오늘은 해당 질문에 대한 답변을 정리해보려 한다. length(): 문자열의 길이를 반환합니다. isEmpty(): 문자열이 비어있는지 확인합니다. equals(Object obj): 주어진 객체와 문자열이 동일한지 비교합니다. equalsIgnoreCase(String str): 대소문자를 무시하고 문자열을 비교합니다. indexOf(String str): 지정된 문자열이 처음으로 나타나는 인덱스를 반환합니다. substring(int beginIndex): 지정된 인덱스부터 문자열 끝까지의 부분 문자열을 반환합니다. substring(int beginIndex, int endIndex): 지정된 범위의 부분 문자열을 반환합니다. split(String regex): 정규식을 기준으로 문자열을 나누어 배열로 반환합니다. toUpperCase(): 문자열의 모든 문자를 대문자로 변환합니다. toLowerCase(): 문자열의 모든 문자를 소문자로 변환합니다. trim(): 문자열의 앞뒤 공백을 제거합니다. replace(char oldChar, char newChar): 지정된 문자를 새로운 문자로 치환합니다. charAt(int index): 지정된 인덱스에 위치한 문자를 반환합니다. contains(CharSequence sequence): 주어진 문자열 또는 문자 시퀀스를 포함하는지 확인합니다. matches(String regex): 정규식과 일치하는지 확인합니다. concat(String str): 다른 문자열을 현재 문자열에 연결합니다. startsWith(String prefix): 주어진 접두어로 시작하는지 확인합니다. endsWith(String suffix): 주어진 접미어로 끝나는지 확인합니다. compareTo(String anotherString): 다른 문자열과의 사전 순서 비교를 수행합니다. compareToIgnoreCase(String str): 대소문자를 무시하고 사전 순서 비교를 수행합니다. format(String format, Object… args): 지정된 포맷으로 문자열을 생성합니다. valueOf(primitive data type): 기본 데이터 타입의 값을 문자열로 변환합니다. getBytes(): 문자열을 바이트 배열로 변환합니다. ","date":"2023-08-20","objectID":"/string_method/:0:0","tags":["Java-Basic","Java","String","Method"],"title":"String_Method","uri":"/string_method/"},{"categories":["Java"],"content":"포스트 작성 시 참고한 링크 문자열 메서드 ","date":"2023-08-20","objectID":"/string_method/:1:0","tags":["Java-Basic","Java","String","Method"],"title":"String_Method","uri":"/string_method/"},{"categories":["Java"],"content":" 커리어리라는 어플을 보다가 주니어 자바 개발자를 위한 100가지 질문을 보게 되었다. 오늘의 질문! 문자열을 반전 시키는 가장 좋은 방법은 무엇인가? 오늘은 해당 질문에 대한 답변을 정리해보려 한다. ","date":"2023-08-20","objectID":"/stringreverser/:0:0","tags":["Java-Basic","Java","String","Reverse","ReverseString","StringBuilder"],"title":"[Java] 문자열을 반전 시키는 가장 좋은 방법","uri":"/stringreverser/"},{"categories":["Java"],"content":"문자열을 반전 시키는 가장 좋은 방법이란 문자열을 반전 시키는 방법은 정말 많이 있다. 예를 들어 반복문을 사용하는 방법, 라이브러리 함수를 이용하는 방법, 재귀함수를 이용하는 방법 등 정말 다양한 방법이 있다. 이 중에서 효율이 좋다고 생각하는 방법 1가지에 대해 알아보고자 한다. ","date":"2023-08-20","objectID":"/stringreverser/:1:0","tags":["Java-Basic","Java","String","Reverse","ReverseString","StringBuilder"],"title":"[Java] 문자열을 반전 시키는 가장 좋은 방법","uri":"/stringreverser/"},{"categories":["Java"],"content":"StringBuilder를 사용해 문자열 반전 시키기 자바에서 문자열을 반전 시키는 가장 일반적인 방법으로 StringBuilder의 reverse() 메서드를 사용하는 방법이다. 이 방법은 가장 효율적인 방법 중 하나입니다. 문자열은 불변 객체이기 때문에 문자열을 직접 수정을 시도하면 매번 힙 영역의 새로운 문자열 객체를 생성하게 된다. 이는 매번 Garbage가 쌓여 메모리 효율을 떨어트릴 수 있으며 StringBuilder를 사용하면 이러한 비 효율성을 줄여줄 수 있다. public class reverseString { String origin = \"Hello World\"; String reverse = new StringBuilder(origin).reverse().toString(); System.out.println(reverse); // 출력: \"dlroW olleH\" } ","date":"2023-08-20","objectID":"/stringreverser/:2:0","tags":["Java-Basic","Java","String","Reverse","ReverseString","StringBuilder"],"title":"[Java] 문자열을 반전 시키는 가장 좋은 방법","uri":"/stringreverser/"},{"categories":["Java"],"content":"포스트 작성 시 참고한 링크 자바 문자열 반전 ","date":"2023-08-20","objectID":"/stringreverser/:3:0","tags":["Java-Basic","Java","String","Reverse","ReverseString","StringBuilder"],"title":"[Java] 문자열을 반전 시키는 가장 좋은 방법","uri":"/stringreverser/"},{"categories":["Java"],"content":" 커리어리라는 어플을 보다가 주니어 자바 개발자를 위한 100가지 질문을 보게 되었다. 오늘은 여러가지 질문 중 String에 대해 알아보고자 한다. String은 기본 데이터 타입인지? 문자열을 조작하는 클래스는 무엇이 있는지? ","date":"2023-08-19","objectID":"/string/:0:0","tags":["Java-Basic","Java","String","Class","StringBuffer","StringBuilder"],"title":"[Java] String은 기본 타입인가? 그리고 StringBuffer, StringBuilder","uri":"/string/"},{"categories":["Java"],"content":"String은 무엇인가? 기본 자료형(int, float, char, boolean)처럼 자주 사용되는 class이다. String은 이 기본 자료형들과는 다르게 참조 자료형 class이다. 참조 자료형이란 객체 자체에 값을 가지는 것이 아닌 객체에는 referenece(주소) 값을 갖고 있고 해당 reference에 객체의 값이 있는 형태다. ","date":"2023-08-19","objectID":"/string/:1:0","tags":["Java-Basic","Java","String","Class","StringBuffer","StringBuilder"],"title":"[Java] String은 기본 타입인가? 그리고 StringBuffer, StringBuilder","uri":"/string/"},{"categories":["Java"],"content":"String은 기본 데이터 타입인가? 위에서도 말씀 드렸지만 String은 기본 데이터 타입이 아닌 참조 자료형 클래스 이다. 기본 타입과 달리 heap 영역에 생성된다. ","date":"2023-08-19","objectID":"/string/:2:0","tags":["Java-Basic","Java","String","Class","StringBuffer","StringBuilder"],"title":"[Java] String은 기본 타입인가? 그리고 StringBuffer, StringBuilder","uri":"/string/"},{"categories":["Java"],"content":"1. 문자열 생성 및 비교 아래와 같이 문자열을 리터럴로 생성한다면 literalName이라는 변수는 스택 영역에 저장되고 문자열인 “최승우\"는 힙 영역에 String 객체로 생성된다. literalName이라는 변수에는 힙 영역에 저장된 주소 값이 저장된다. 따라서 문자열 리터럴이 동일한 경우 같은 주소 값을 저장하게 돼 ==와 .equals 상관 없이 같다고 나온다. 다만, new 연산자를 사용하여 객체를 생성하면 문자열의 값이 같더라도 다른 주소 값을 저장하기 때문에 ==을 사용하면 다르다고 출력한다. 따라서 저장된 값을 비교하고 싶으면 equals()를 사용해야 한다. public class StringTest { String literalName = \"최승우\"; String newName = new String(\"최승우\"); System.out.println(literalName == newName); // false System.out.println(literalName.equals(newName)); // true } ","date":"2023-08-19","objectID":"/string/:2:1","tags":["Java-Basic","Java","String","Class","StringBuffer","StringBuilder"],"title":"[Java] String은 기본 타입인가? 그리고 StringBuffer, StringBuilder","uri":"/string/"},{"categories":["Java"],"content":"2. 가변성을 갖고 있는 StringBuilder와 StringBuffer 들어가기 앞서, String은 불변속성을 갖는다. 만약, 아래와 같이 sayHello라는 변수에 안녕!이라는 값을 리터럴로 생성하면 힙 영역에 String 객체로 생성하고, 그 이후 \" 승우야!“라는 값을 추가하게 되면 해당 객체에 “안녕 승우야!” 라는 값으로 변경했다고 생각할 수 있다. 하지만 기존에 “안녕!“이 들어가 있던 객체를 참조하던 sayHello 변수는 힙 영역에 “안녕 승우야!“의 값을 갖고 있는 객체를 새로 생성한 후 해당 주소 값을 바라보고 있도록 변경된 것이고 처음 생성되었던 “안녕!“이라는 값을 갖고 있는 메모리 영역은 Garbage로 남아 있다가 GC(Garbage Collection)에 의해 사라지게 된다. 이는, String 클래스는 불변하며 문자열을 수정하는 시점에 새로운 String 인스턴스가 생성된다는 것을 의미한다. 이 처럼 String은 불변하기 때문에 빈번한 수정이 있는 경우 힙 메모리 영역에 많은 Garbage가 쌓이므로 성능의 치명적인 영향을 끼친다. 그래서 가변성을 갖고 있는 StringBuilder와 StringBuffer 클래스를 도입했다. 이 두 클래스는 .append(), .delete()를 이용하여 동일 객체내에서 문자열을 변경하는 것이 가능하다. 문자열의 추가, 수정, 삭제가 빈번하게 발생하는 경우 이 두가지 클래스를 사용하는 것이 적합하다. ","date":"2023-08-19","objectID":"/string/:2:2","tags":["Java-Basic","Java","String","Class","StringBuffer","StringBuilder"],"title":"[Java] String은 기본 타입인가? 그리고 StringBuffer, StringBuilder","uri":"/string/"},{"categories":["Java"],"content":"3. StringBuffer, StringBuilder의 차이점 가장 큰 차이점은 동기화 유무 이다. Buffer는 동기화 키워드를 지원하여 멀티 쓰레드 환경에서 안전하다는 점(thread-safe) 참고로 String도 불변성을 갖기 때문에 멀티 쓰레드 환경에서의 안성정을 갖고 있다. Builder는 동기화를 지원하지 않기 때문에 멀티 쓰레드 환경에서 사용하는 것은 적합하지 않지만 동기화를 고려하지 않는 만큼 단일 쓰레드에서의 성능은 Buffer보다 뛰어나다. ","date":"2023-08-19","objectID":"/string/:2:3","tags":["Java-Basic","Java","String","Class","StringBuffer","StringBuilder"],"title":"[Java] String은 기본 타입인가? 그리고 StringBuffer, StringBuilder","uri":"/string/"},{"categories":["Java"],"content":"4. 정리 간단히 정리하면, String은 불변성으로 인해 안전하고 쓰기 쉽지만 문자열을 자주 조작하는 경우 오버헤드가 발생할 수 있습니다. StringBuilder는 가변성으로 인해 자주 조작하는 경우 효율적이고, 단일 스레드 환경에서 사용하기 적합합니다. StringBuffer는 StringBuilder와 유사하게 가변성을 제공하면서 멀티스레드 환경에서도 안전하게 사용할 수 있습니다. 따라서 단일 스레드 환경에서는 StringBuilder를, 멀티스레드 환경에서는 StringBuffer를 선호하는 것이 좋습니다. 문자열 연산이 적고 멀티 쓰레드인 경우 : String 문자열 연산이 많고 멀티 쓰레드인 경우 : StringBuffer 문자열 연산이 많고 단일 쓰레드이거나 동기화를 고려하지 않아도 되는 경우 : StringBuilder ","date":"2023-08-19","objectID":"/string/:2:4","tags":["Java-Basic","Java","String","Class","StringBuffer","StringBuilder"],"title":"[Java] String은 기본 타입인가? 그리고 StringBuffer, StringBuilder","uri":"/string/"},{"categories":["Java"],"content":"포스트 작성 시 참고한 링크 String 클래스 문자열 조작 클래 ","date":"2023-08-19","objectID":"/string/:3:0","tags":["Java-Basic","Java","String","Class","StringBuffer","StringBuilder"],"title":"[Java] String은 기본 타입인가? 그리고 StringBuffer, StringBuilder","uri":"/string/"},{"categories":["Java"],"content":" 커리어리라는 어플을 보다가 주니어 자바 개발자를 위한 100가지 질문을 보게 되었다. 오늘은 여러가지 질문 중 Math 클래스에 대해 알아보고자 한다. ","date":"2023-08-19","objectID":"/math/:0:0","tags":["Java-Basic","Java","Math","Class"],"title":"[Java] Math 클래스","uri":"/math/"},{"categories":["Java"],"content":"Math 클래스란? 자바에서 제공되는 유틸리티 클래스로 자주 사용하는 상수들과 함수들을 미리 구현해 놓은 클래스입니다. ","date":"2023-08-19","objectID":"/math/:1:0","tags":["Java-Basic","Java","Math","Class"],"title":"[Java] Math 클래스","uri":"/math/"},{"categories":["Java"],"content":"1. Math에 정의된 대표적인 상수 Math.PI : 원주율 π (약 3.141592653589793) Math.E : 자연 상수 e (약 2.718281828459045) ","date":"2023-08-19","objectID":"/math/:1:1","tags":["Java-Basic","Java","Math","Class"],"title":"[Java] Math 클래스","uri":"/math/"},{"categories":["Java"],"content":"2. Math에 정의된 대표적인 메서드 abs(int a) / abs(long a) : 정수의 절댓값을 반환합니다. ceil(double a) : 주어진 숫자보다 크거나 같은 최소 정수를 반환합니다. floor(double a) : 주어진 숫자보다 작거나 같은 최대 정수를 반환합니다. round(float a) / round(double a) : 주어진 숫자를 반올림하여 long 형태로 반환합니다. min(int a, int b) / min(long a, long b) : 두 정수 중 작은 값을 반환합니다. max(int a, int b) / max(long a, long b) : 두 정수 중 큰 값을 반환합니다. sqrt(double a) : 주어진 숫자의 제곱근을 반환합니다. pow(double a, double b) : a의 b승을 반환합니다. sin(double a), cos(double a), tan(double a) : 삼각 함수 값들을 반환합니다. random() : 0 이상 1 미만의 난수를 반환합니다. (0.0 \u003c= x \u003c 1.0) ","date":"2023-08-19","objectID":"/math/:1:2","tags":["Java-Basic","Java","Math","Class"],"title":"[Java] Math 클래스","uri":"/math/"},{"categories":["Java"],"content":"3. 각 메서드 사용 및 결과 Math.abs(-1.5) : 1.5 Math.ceil(-1.5) : -1.0 Math.floor(-1.5) : -2.0 Math.round(-1.5) : -2 Math.min(-1.5, 3.0) : -1.5 Math.max(-1.5, 3.0) : 3.0 Math.sqrt(-1.5) : NaN (Not a Number : 제곱근이 실수 범위 내에 없기 때문에 이 경우 허수와 관련된 복소수 연산이 필요하며 Math 클래스에서는 지원하지 않음) Math.sqrt(4) : 2.0 Math.pow(-1.5, 2.0): 2.25 Math.sin(-1.5): -0.9974949866040544 Math.cos(-1.5): 0.0707372016677029 Math.tan(-1.5): -14.101419947171719 Math.random(): [0.0, 1.0) 범위의 난수 (실행할 때마다 값이 달라집니다) Math.random() * 100 : 0 ~ 99 까지 랜덤으로 1가지의 수 ","date":"2023-08-19","objectID":"/math/:1:3","tags":["Java-Basic","Java","Math","Class"],"title":"[Java] Math 클래스","uri":"/math/"},{"categories":["Java"],"content":"포스트 작성 시 참고한 링크 Math 클래스 ","date":"2023-08-19","objectID":"/math/:2:0","tags":["Java-Basic","Java","Math","Class"],"title":"[Java] Math 클래스","uri":"/math/"},{"categories":["Java"],"content":" 프로젝트를 하다보면 각자 다른 네이밍을 사용하다 보니 다른 사람이 작업한 코드를 보면 헷갈릴 때가 있다. 그래서 나온것이 표준 네이밍 규칙이며 보통 권장사항 이다보니 많이 놓치고 있어서 한번 정리해보려 한다! 오늘 정리할 네이밍 규칙은 Java 이다. ","date":"2023-08-19","objectID":"/naming/:0:0","tags":["Java-Basic","Java","Naming","Convention"],"title":"[Java] 자바 네이밍 규칙(Java Naming Convention)","uri":"/naming/"},{"categories":["Java"],"content":"1. 네이밍 규칙이란? 프로그래밍에서 변수, 함수, 클래스, 상수, 패키지 등의 작성할 때 따르는 규칙이다. 이러한 규칙을 따르면 코드의 가독성이 좋아지고 일관석 있게 작성할 수 있다. ","date":"2023-08-19","objectID":"/naming/:1:0","tags":["Java-Basic","Java","Naming","Convention"],"title":"[Java] 자바 네이밍 규칙(Java Naming Convention)","uri":"/naming/"},{"categories":["Java"],"content":"2. 네이밍 규칙을 사용하면 따라오는 효과 가독성 향상 : 의미 있는 단어를 사용해 코드의 의도를 쉽게 알 수 있고, 유지보수나 협업에 도움이 된다. 일관성 유지 : 일관된 네이밍 규칙을 따르면 코드가 전체적으로 일관성 있어 다양한 파일과 모듈 간의 이동과 이해를 용이하게 만든다. 버그 감소 : 명확한 이름을 사용하면 변수나 함수의 역할을 파악하기 쉬워지므로 실수나 버그 발생 가능성이 줄어든다. ","date":"2023-08-19","objectID":"/naming/:2:0","tags":["Java-Basic","Java","Naming","Convention"],"title":"[Java] 자바 네이밍 규칙(Java Naming Convention)","uri":"/naming/"},{"categories":["Java"],"content":"3. 자바 네이밍 규칙 ","date":"2023-08-19","objectID":"/naming/:3:0","tags":["Java-Basic","Java","Naming","Convention"],"title":"[Java] 자바 네이밍 규칙(Java Naming Convention)","uri":"/naming/"},{"categories":["Java"],"content":"1. 공통 규칙 대소문자가 구분되어야 하고 길이에 제한이 없다. 예약어는 사용하면 안된다.(ex : class, import, char, break 등···) 숫자로 시작하면 안된다. 특수문자는 ‘_’(언더바)와 ‘$’(달러 기호)만 사용 가능하다. 파스칼 표기법과 카멜 표기법을 사용한다. 파스칼 표기법 : 모든 단어의 첫 번째 문자는 대문자이며 나머지는 소문자로 작성한다. (ex : PasclaCase ) 카멜 표기법 : 최초로 사용되는 단어는 모두 소문자로 작성하고 그 이후 첫번째 문자는 대문자 나머지는 소문자로 작성한다. (ex : camelCase) 반의어는 반드시 대응하는 개념으로 사용해야 한다. (반의어 종류 보러가기) ","date":"2023-08-19","objectID":"/naming/:3:1","tags":["Java-Basic","Java","Naming","Convention"],"title":"[Java] 자바 네이밍 규칙(Java Naming Convention)","uri":"/naming/"},{"categories":["Java"],"content":"2. 패키지 명명 규칙 소문자로 시작(모든 소문자를 권장) 가급적 한던어 사용 권장 표준 패턴 권장(com.(회사명 / 팀 이름).프로젝트명.상위패키지.하위패키지.클래스) ex : com.choi.management.user.controller ","date":"2023-08-19","objectID":"/naming/:3:2","tags":["Java-Basic","Java","Naming","Convention"],"title":"[Java] 자바 네이밍 규칙(Java Naming Convention)","uri":"/naming/"},{"categories":["Java"],"content":"3. 클래스 명명 규칙 파스칼 표기법 사용 명사 시작 ex : UserController ","date":"2023-08-19","objectID":"/naming/:3:3","tags":["Java-Basic","Java","Naming","Convention"],"title":"[Java] 자바 네이밍 규칙(Java Naming Convention)","uri":"/naming/"},{"categories":["Java"],"content":"4. 인터페이스 명명 규칙 클래스랑 비슷한 명명 규칙을 갖고있다. 복수형 개념인 경우 복수형을 작성해준다. 축약어, 약어는 가급적 작성하지 않고 의미있는 단어로만 작성한다. 특별한 접두사나 접미사를 사용하지 않고 파스칼 표기법 사용 형용사 사용 할 수 있다.(Runnable, Remote 등…) ex : ConvertUserToMemberHandler ","date":"2023-08-19","objectID":"/naming/:3:4","tags":["Java-Basic","Java","Naming","Convention"],"title":"[Java] 자바 네이밍 규칙(Java Naming Convention)","uri":"/naming/"},{"categories":["Java"],"content":"5. 인터페이스 명명 규칙 클래스랑 비슷한 명명 규칙을 갖고있다. 복수형 개념인 경우 복수형을 작성해준다. 축약어, 약어는 가급적 작성하지 않고 의미있는 단어로만 작성한다. 특별한 접두사나 접미사를 사용하지 않고 파스칼 표기법 사용 형용사 사용(Runnable, Remote 등···) ex : ConvertUserToMemberHandler ","date":"2023-08-19","objectID":"/naming/:3:5","tags":["Java-Basic","Java","Naming","Convention"],"title":"[Java] 자바 네이밍 규칙(Java Naming Convention)","uri":"/naming/"},{"categories":["Java"],"content":"6. 메서드 명명 규칙 카멜 표기법 사용한다. 동사로 시작한다. ex : sendMessage(String message) ","date":"2023-08-19","objectID":"/naming/:3:6","tags":["Java-Basic","Java","Naming","Convention"],"title":"[Java] 자바 네이밍 규칙(Java Naming Convention)","uri":"/naming/"},{"categories":["Java"],"content":"7. 변수 명명 규칙 카멜 표기법 사용한다. 명확한 이름으로 작성한다. boolean으로 가져올 때는 앞에 is를 붙인다. ex : userName, isChecked ","date":"2023-08-19","objectID":"/naming/:3:7","tags":["Java-Basic","Java","Naming","Convention"],"title":"[Java] 자바 네이밍 규칙(Java Naming Convention)","uri":"/naming/"},{"categories":["Java"],"content":"8. 상수 명명 규칙 전부 대문자료 표기한다. 스네이크 케이스를 사용한다.(Snake Case : 단어와 단어 사이를 언더바(’_’)로 구분) ex : PI, MAX_COUNT public class Score() { // final 변수 선언과 초기화(최대 점수 : 100점) // 만약 초기화를 비어둔다면 추후에 초기화가 불가능 하다...(반드시 선언과 동시에 초기화 해주자!!) // 자바 명명 규칙은 나중에 게시물로 상세하게 작성해보겠다! 오늘 사용하는 상수는 대문자로! 단어와 단어 사이는 언더바를 이용한다! final int MAX_SCORE = 100; // 컴파일 에러가 발생 MAX_SCORE = 60; } final 메서드 오버라이딩 방지 안정성 확보(의도하지 않은 동작 변경 방지, 일관성 유지) final class Exam { // 시험의 최대 점수는 final로 선언하고 name은 변수로 선언 private final int MAX_SCORE = 100; private String name; // 이름 입력 public setName(String name) { this.name = name; } // 이름 가져오기 public String getName() { return name; } // 최대 점수 가져오기 public final String getMaxScore() { return MAX_SCORE; } } class MathExam extends Exam { // 이름 가져오기 메서드 오버라이딩 가능 public String getName() { System.out.println(\"이름 : \" + name); return name; } // 컴파일 에러 발생(최대 점수 가져오기 메서드를 오버라이딩 불가) public final String getMaxScore() { // ... } } final 클래스 상속이 불가능 메서드 오버라이딩이 불가능 해당 클래스를 변경하지 못하기 때문에 보안성 및 안정성이 강화 final class Exam { // 시험의 최대 점수는 final로 선언하고 name은 변수로 선언 private final int MAX_SCORE = 100; private String name; // 이름 입력 public setName(String name) {스 this.name = name; } // 이름 가져오기 public String getName() { return name; } // 최대 점수 가져오기 public String getMaxScore() { return MAX_SCORE; } } // 아래의 코드는 컴파일 에러 발생 class MathExam extends Exam { // ... } ","date":"2023-08-19","objectID":"/naming/:3:8","tags":["Java-Basic","Java","Naming","Convention"],"title":"[Java] 자바 네이밍 규칙(Java Naming Convention)","uri":"/naming/"},{"categories":["Java"],"content":"반의어 돌아가기(자바 네이밍 공통 규칙 보러가기) get / set : 가져오다. / 할당하다. (ex : getAge() / setAge() ) add / delete : 추가하다. / 제거하다. (ex : addUser() / deleteUser() ) insert / delete : 삽입 / 삭제 (ex : insertUser() / deleteUser() ) min / max : 최소 / 최대 (ex : minCnt() / maxCnt() ) show / hide : 보이다 / 숨기다 (ex : showMove() / hideMove() ) start / stop : 시동 / 정지 (ex : startMethod() / stopMethod() ) suspend / resume : 일시 정지 / 재개하다 (ex : suspendMove() / resumeMove() ) increment / decrement : 증가 / 감소 (ex : incrementViews() / decrementViews() ) create / destroy : 창조하다. / 파괴하다. (ex : createMap() / destroyMap() ) next / previous : 다음 / 이전 (ex : nextUser() / previousUser() ) open / close : 열다 / 닫다 (ex : openFile() / closeFile() ) ","date":"2023-08-19","objectID":"/naming/:4:0","tags":["Java-Basic","Java","Naming","Convention"],"title":"[Java] 자바 네이밍 규칙(Java Naming Convention)","uri":"/naming/"},{"categories":["Java"],"content":"포스트 작성 시 참고한 링크 자바 네이밍 규칙 - 1 자바 네이밍 규칙 - 2 ","date":"2023-08-19","objectID":"/naming/:5:0","tags":["Java-Basic","Java","Naming","Convention"],"title":"[Java] 자바 네이밍 규칙(Java Naming Convention)","uri":"/naming/"},{"categories":["Java"],"content":" 커리어리라는 어플을 보다가 주니어 자바 개발자를 위한 100가지 질문을 보게 되었다. 오늘은 여러가지 질문 중 final에 대해 알아보고자 한다. ","date":"2023-07-22","objectID":"/final/:0:0","tags":["Java-Basic","Java","final"],"title":"[Java] final 사용법","uri":"/final/"},{"categories":["Java"],"content":"java에서 final 키워드란 뭘까? ","date":"2023-07-22","objectID":"/final/:1:0","tags":["Java-Basic","Java","final"],"title":"[Java] final 사용법","uri":"/final/"},{"categories":["Java"],"content":"1. final 의미 자바에서 final은 변수, 메서드, 클래스에 사용되는 키워드로서 불변성을 나타낸다. final로 선언된 요소는 한번 초가화하면 그 값을 변경할 수 없다. 예를 들면 정보처리기사라는 시험의 점수는 고정되어 있다! 시험을 보는 사람마다 점수가 다르게 선정된다면 혼란을 야기할듯.. 다만, 시험보는 사람의 수험번호와 같은 경우 모든 사람이 다를 것이다. 이와 같은 경우 각각의 점수를 final로 이름을 변수로 선언하는 것이 바람직하다! ","date":"2023-07-22","objectID":"/final/:1:1","tags":["Java-Basic","Java","final"],"title":"[Java] final 사용법","uri":"/final/"},{"categories":["Java"],"content":"2. final 종류 final 변수 값 변경 불가능 컴파일 시간 상수(final 변수는 컴파일 시간에 값을 결정하므로, 값을 바로 인라인하여 코드 삽입 가능) 인스턴스와 정적 변수에 적용 가능 public class Score() { // final 변수 선언과 초기화(최대 점수 : 100점) // 만약 초기화를 비어둔다면 추후에 초기화가 불가능 하다...(반드시 선언과 동시에 초기화 해주자!!) // 자바 명명 규칙은 나중에 게시물로 상세하게 작성해보겠다! 오늘 사용하는 상수는 대문자로! 단어와 단어 사이는 언더바를 이용한다! final int MAX_SCORE = 100; // 컴파일 에러가 발생 MAX_SCORE = 60; } final 메서드 오버라이딩 방지 안정성 확보(의도하지 않은 동작 변경 방지, 일관성 유지) final class Exam { // 시험의 최대 점수는 final로 선언하고 name은 변수로 선언 private final int MAX_SCORE = 100; private String name; // 이름 입력 public setName(String name) { this.name = name; } // 이름 가져오기 public String getName() { return name; } // 최대 점수 가져오기 public final String getMaxScore() { return MAX_SCORE; } } class MathExam extends Exam { // 이름 가져오기 메서드 오버라이딩 가능 public String getName() { System.out.println(\"이름 : \" + name); return name; } // 컴파일 에러 발생(최대 점수 가져오기 메서드를 오버라이딩 불가) public final String getMaxScore() { // ... } } final 클래스 상속이 불가능 메서드 오버라이딩이 불가능 해당 클래스를 변경하지 못하기 때문에 보안성 및 안정성이 강화 final class Exam { // 시험의 최대 점수는 final로 선언하고 name은 변수로 선언 private final int MAX_SCORE = 100; private String name; // 이름 입력 public setName(String name) { this.name = name; } // 이름 가져오기 public String getName() { return name; } // 최대 점수 가져오기 public String getMaxScore() { return MAX_SCORE; } } // 아래의 코드는 컴파일 에러 발생 class MathExam extends Exam { // ... } ","date":"2023-07-22","objectID":"/final/:1:2","tags":["Java-Basic","Java","final"],"title":"[Java] final 사용법","uri":"/final/"},{"categories":["Java"],"content":"포스트 작성 시 참고한 링크 자바에서 final에 대한 이해 ","date":"2023-07-22","objectID":"/final/:2:0","tags":["Java-Basic","Java","final"],"title":"[Java] final 사용법","uri":"/final/"},{"categories":["Java"],"content":" 커리어리라는 어플을 보다가 주니어 자바 개발자를 위한 100가지 질문을 보게 되었다. 8개월 동안 회사에서 프로젝트를 여러개 진행하면서 다양한 기술을 사용해봤다. 하지만 기초 및 이론 공부는 굉장히 소홀했었다.. 기초가 단단하지 않으면 나의 개발 스펙트럼도 짧아 질것 같아서 하나하나 정리해보려 한다. 요즘 다시 괜찮아져서 블로그도 다시 시작… 화이팅..! ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:0:0","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"[Java] JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["Java"],"content":"들어가기 앞서 오늘은 자바 플랫폼에 대해 알아보고자 한다. JDK, JRE, JVM은 자바 플랫폼의 3대 구성요소이다. 오늘은 JDK, JRE, JVM에 추가로 JIT까지 알아보고자 한다. 이미지를 먼저 확인 후 본격적으로 들어가보자..! JDK와 JRE 그리고 JVM ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:1:0","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"[Java] JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["Java"],"content":"JDK(Java Development Kit : 자바 개발 키트) ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:2:0","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"[Java] JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["Java"],"content":"1. JDK는 무엇일까? Java를 사용하기 위해 모든 기능을 갖춘 SDK(Software Development Kit) JRE를 포함한 컴파일러(javac)와 jdb, javadoc 같은 도구를 포함 즉, 프로그램을 생성하고 컴파일 할 수 있다. ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:2:1","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"[Java] JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["Java"],"content":"2. JDK 종류 Java SE(Java Standard Edition) 표준 에디션의 자바 플랫폼, 자바 언어의 핵심 기능 제공 주요패키지 java.lang.*, java.io.*, java.util.*, java.awt.*, java.rmi.*, java.net.* Java EE(Java Enterprise Edition) Java SE에 웹 애플리케이션 서버에서 동작하는 기능을 추가한 플랫폼 즉, 서버측 개발을 하기 위해 필요(JSP, Servlet, JDBC 등 기업용 애플리케이션 개발에 필요한 다양한 플랫폼) 이 스펙에 따라 제품을 구현한 것이 WAS로 부름 Java ME(Java Micro Edition) 임베디드 기기들에서 구동되기 위한 환경을 제공하는 API를 모아둔 플랫폼 제한된 자원을 가진 휴대전화, PDA(소형 전자 기기) 등에서 Java 프로그래밍 언어를 지원하기 위해 만든 플랫폼 ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:2:2","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"[Java] JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["Java"],"content":"3. JDK 기본 도구 javac : 자바 컴파일러(자바 소스파일 =\u003e 바이트 코드) java : javac가 만든 클래스 파일을 해석 및 실행 jdb : 자바 디버깅 툴 ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:2:3","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"[Java] JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["Java"],"content":"JRE(Java Runtime Environment : 자바 런타임 환경) ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:3:0","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"[Java] JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["Java"],"content":"1. JRE는 무엇일까? 자바로 만든 애플리케이션을 실행할 수 있는 런타임 환경 구축 JVM과 핵심 라이브러리 및 자바 런타임 환경에서 사용하는 프로퍼티 세팅이나 리소스 파일 제공 JDK와 달리 개발하는데 필요한 툴은 제공되지 않는다. 클래스 로더, 클래스 라이브러리를 통해 작성한 코드를 라이브러리와 결합 후 JVM에 넘겨 실행 JRE는 특별한 기능을 수행하기 보단 JVM이 원할하게 잘 작동할 수 있도록 환경에 맞춰주는 역할 ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:3:1","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"[Java] JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["Java"],"content":"2. JRE 구성요소 JVM(Java Virtual Machine) : 자바 가상 머신으로 아래 따로 다루겠습니다. Java Class Libraries : 개발하면서 자주 사용하는 여러 유용한 기능들을 모아놓은 클래스 집합 라이브러리 Java Class Loader : JVM이 동작하다가 클래스 파일을 참조하는 순간 동적으로 읽어 JVM에 링크되고 메모리에 로딩하는 역할 ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:3:2","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"[Java] JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["Java"],"content":"JVM(Java Virtual Machine : 자바 가상 머신) ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:4:0","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"[Java] JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["Java"],"content":"1. JVM은 무엇일까? 자바 프로그램이 어느 기기, 운영체제 상에서도 실행될 수 있도록 만듦(WORA : 한 번 쓰고 모든 곳에서 실행한다) 메모리를 효율적으로 관리 및 최적화(Garbage Collection) JVM은 단독으로 사용이 불가, 최소 배포 단위는 JRE이다. ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:4:1","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"[Java] JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["Java"],"content":"2. 가비지 컬렉션(Garbage Collection)? JVM이 메모리를 관리하는 프로세스 사용하지 않는 메모리를 지속적으로 찾아 제거해 효육적인 메모리 관리 가비지 컬렉션 ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:4:2","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"[Java] JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["Java"],"content":"JIT(Just In Time Compilation) 방식 ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:5:0","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"[Java] JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["Java"],"content":"1. JIT는 무엇일까? 프로그램을 실제 실행하는 시점에 기계어로 번역하는 컴파일 기법 ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:5:1","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"[Java] JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["Java"],"content":"2. 컴파일 기법 컴파일 기법에는 인터프리터 방식와 컴파일러 방식로 나뉨 인터프리터 방식는 코드를 한 줄씩 중간 코드인 바이트 코드로 변환 후 실행 컴파일링 방식는 코드 실행 전, 소스 코드를 한번에 기계어로 변환 후 실행 컴파일 기법 ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:5:2","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"[Java] JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["Java"],"content":"3. Java 컴파일 기법 자바는 컴파일러 방식을 사용한다 Java Compiler를 통해 Byte Code로 변환되고 다시 기계어로 변환된다. 이 과정이 있기 때문에 느리다 평가가 존재한다. 이러한 단점을 극복하기 위해 JIT 방식이 채택되었다. ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:5:3","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"[Java] JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["Java"],"content":"4. JIT 방식 자주 쓸만한 코드들을 기계어로 변환 시켜놓고 저장 후 이미 변환된 기계어 코드를 재사용하는 방식 ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:5:4","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"[Java] JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["Java"],"content":"포스트 작성 시 참고한 링크 JDK(Java Development Kit) JRE(Java Development Kit) JVM(Java Virtual Machine) JIT(Just In Time Compilation) ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:6:0","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"[Java] JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["WebSocket"],"content":" 일을 하던 중 프로그래스 바와 같은 작업의 완료 타이밍을 알 수 있는 방법이 있을까? 같은 고민을 하다가 WebSocket을 알게 되었고 그 과정을 글로 작성해보려고 한다. ","date":"2023-05-06","objectID":"/websocket/:0:0","tags":["WebSocket","Java","Spring-Boot","웹소켓"],"title":"[Java] Spring Boot, Websocket + STOMP 사용하기","uri":"/websocket/"},{"categories":["WebSocket"],"content":"Web Socket을 사용한 코드 게시물은 추후에 작성하겠습니다!! 아래 코드는 첨부했습니다! ","date":"2023-05-06","objectID":"/websocket/:1:0","tags":["WebSocket","Java","Spring-Boot","웹소켓"],"title":"[Java] Spring Boot, Websocket + STOMP 사용하기","uri":"/websocket/"},{"categories":["WebSocket"],"content":"포스트 작성 시 참고한 링크 코드 ","date":"2023-05-06","objectID":"/websocket/:2:0","tags":["WebSocket","Java","Spring-Boot","웹소켓"],"title":"[Java] Spring Boot, Websocket + STOMP 사용하기","uri":"/websocket/"},{"categories":["WebSocket"],"content":" 일을 하던 중 프로그래스 바와 같은 작업의 완료 타이밍을 알 수 있는 방법이 있을까? 같은 고민을 하다가 WebSocket을 알게 되었고 그 과정을 글로 작성해보려고 한다. ","date":"2023-05-06","objectID":"/servereventtoclient/:0:0","tags":["WebSocket","Java","Spring-Boot","웹소켓"],"title":"[Java] 서버에서 클라이언트로 이벤트를 보내는 4가지 방법","uri":"/servereventtoclient/"},{"categories":["WebSocket"],"content":"서버에서 클라이언트로 이벤트를 보내는 4가지 방법 ","date":"2023-05-06","objectID":"/servereventtoclient/:1:0","tags":["WebSocket","Java","Spring-Boot","웹소켓"],"title":"[Java] 서버에서 클라이언트로 이벤트를 보내는 4가지 방법","uri":"/servereventtoclient/"},{"categories":["WebSocket"],"content":"1. Polling 클라이언트가 평벙한 http request를 서버로 계속 날려서 이벤트 내용을 받는 방법 가장 쉬운 방법이지만 클라이언트가 지속적으로 request를 보내야 하기 때문에 클라이언트가 많아 질 수록 서버 부담이 급증 실시간으로 정보를 응답 받는 것이 아닌 반복해서 request를 보내는 사이에 바뀐 내용을 받아오는 방식 http 오버헤드가 발생한다는 큰 단점. 하지만 일정 시간 갱신되는 서버 데이터의 경우 유용. Polling 방식 ","date":"2023-05-06","objectID":"/servereventtoclient/:1:1","tags":["WebSocket","Java","Spring-Boot","웹소켓"],"title":"[Java] 서버에서 클라이언트로 이벤트를 보내는 4가지 방법","uri":"/servereventtoclient/"},{"categories":["WebSocket"],"content":"2. Long Polling 서버 측에서 접속을 열어두는 시간을 길게하는 빙식 클라이언트가 서버에 http request를 날리면 서버에서 응답해야할 이벤트가 발생하면 그 순간 응답을 하는 방식 응답을 받은 클라이언트는 바로 http request를 날려 다음 이벤트 대기 polling 방식보다 서버 부담은 줄지만 이벤트 발생 간격이 좁다면 polling이랑 다르지 않음 다수의 클라이언트에게 동시에 이벤트가 발생될 경우 클라이언트가 바로 접속을 시도하면서 서버 부담이 급증 Long Polling 방식 ","date":"2023-05-06","objectID":"/servereventtoclient/:1:2","tags":["WebSocket","Java","Spring-Boot","웹소켓"],"title":"[Java] 서버에서 클라이언트로 이벤트를 보내는 4가지 방법","uri":"/servereventtoclient/"},{"categories":["WebSocket"],"content":"3. WebSocket 양방향 채널을 이용해 채팅방 처럼 양방향 통신하는 방식 기존 http요청 응답 방식은 요청한 클라이언트에 응답만 가능했지만, ws 프로토콜을 통해 웹소켓 포트에 접속해 있는 모든 클라이언트에 이벤트 응답 가능 최초 접속이 일반 http request를 통해 handshaeking 과정을 통해 이루어 지기 때문에, 기존 80, 443포트로 접속하므로 추가 방화벽을 열지 않아도 가능 http 규격인 CORS 적용이나 인증등의 과정을 기존과 동일하다는 장점 단, websocket 프로토콜을 처리하기 위한 전이중 연결과 새로운 웹소켓 서버 필요 WebSocket 방식 ","date":"2023-05-06","objectID":"/servereventtoclient/:1:3","tags":["WebSocket","Java","Spring-Boot","웹소켓"],"title":"[Java] 서버에서 클라이언트로 이벤트를 보내는 4가지 방법","uri":"/servereventtoclient/"},{"categories":["WebSocket"],"content":"4. SSE(Server-Sent-Events) HTML5 표준안이며 어느정도 웹소켓의 역할을 하면서 가벼움 WebSocket과 같이 양방향이 아닌 server -\u003e client 단방향이기 때문에 서버에서 이벤트나 메시지를 client로 push 하는 작업에 유용 양방향이 아니라 요청 시 ajax로 쉽게 이용 재접속 처리 같은 대부분이 저수준 처리가 자동 지원 IE는 기본 미지원이지만, polyFill을 이용할 경우 IE를 포함한 크로스브라우징 가능 SSE(Server-Sent Event) 방식 ","date":"2023-05-06","objectID":"/servereventtoclient/:1:4","tags":["WebSocket","Java","Spring-Boot","웹소켓"],"title":"[Java] 서버에서 클라이언트로 이벤트를 보내는 4가지 방법","uri":"/servereventtoclient/"},{"categories":["WebSocket"],"content":"WebSocket + Stomp를 이용하여 서버와 양방향 통신 다음 게시물은 WebSocket과 Stomp를 이용하여 서버와 양방향 통신을 하는 방법에 대해 스몰 모듈 프로젝트를 만들고자 한다. ","date":"2023-05-06","objectID":"/servereventtoclient/:2:0","tags":["WebSocket","Java","Spring-Boot","웹소켓"],"title":"[Java] 서버에서 클라이언트로 이벤트를 보내는 4가지 방법","uri":"/servereventtoclient/"},{"categories":["WebSocket"],"content":"포스트 작성 시 참고한 링크 서버에서 클라이언트로 이벤트를 보내는 4가지 방법 ","date":"2023-05-06","objectID":"/servereventtoclient/:3:0","tags":["WebSocket","Java","Spring-Boot","웹소켓"],"title":"[Java] 서버에서 클라이언트로 이벤트를 보내는 4가지 방법","uri":"/servereventtoclient/"},{"categories":["Docker"],"content":" Mysql을 사용하여 프로젝트를 하나 진행 중이었습니다. 해당 프로젝트가 끝나고 새로운 프로젝트를 진행하게 되었는데, 새로운 프로젝트에서는 MariaDB를 사용해야하는 상황이었고, Mysql과 MariaDB는 서로 프로토콜, 프로세스 명, 명령어 등을 쉐어하고 있다고 알려져 있어 MySql이 설치되어있는 상황에서 MariaDB를 다운하면 충돌이 발생하고 MySql을 지우고 다운받을 수 없는 상황이라 동시에 사용하기 위해 Docker로 설치해여 사용하려 합니다. ","date":"2023-03-17","objectID":"/docker%EB%9E%80/:0:0","tags":["Docker"],"title":"[Docker] Docker는 뭘까?","uri":"/docker%EB%9E%80/"},{"categories":["Docker"],"content":"Docker?? 컨테이너 기반의 오픈소스 가상화 플랫폼 다양한 프로그램, 실행 환경을 컨테이너로 추상화하고 동일한 인터페이스를 제공하여 프로그램 배포 및 관리를 단순화 한다. 컨테이너 엔진으로 리눅스 커널 기능을 사용하여 운영체제 위에 컨테이너를 만들고, 데몬으로 실행된다. Linux 커널의 도커 엔진 ","date":"2023-03-17","objectID":"/docker%EB%9E%80/:1:0","tags":["Docker"],"title":"[Docker] Docker는 뭘까?","uri":"/docker%EB%9E%80/"},{"categories":["Docker"],"content":"컨테이너?? 호스트 OS상에 논리적인 구획(컨테이너)을 만들고, 어플리케이션을 작동시키기 위해 필요한 라이브러리나 어플리케이션 등을 하나로 모아, 마치 별도의 서버인 것처럼 사용할 수 있게 만든 것 컨테이너는 오버헤드가 적기 때문에 가볍고 고속으로 작동하는 것이 특징입니다. ","date":"2023-03-17","objectID":"/docker%EB%9E%80/:2:0","tags":["Docker"],"title":"[Docker] Docker는 뭘까?","uri":"/docker%EB%9E%80/"},{"categories":["Docker"],"content":"Docker Image?? Docker에서 image는 파일로 어플리케이션 실행에 필요한 독립적인 환경을 포함한 일종의 템플릿 소스 코드, 라이브러리, 종속성, 도구 및 응용 프로그램을 실행하는데 필요한 기타 파일을 포함하는 불변 파일 읽기 전용이며 스냅샷 이라고도 부르고 이러한 일관성은 개발자에게 안정적이고 균일한 조건에서 테스트 할 수 있도록 함. ","date":"2023-03-17","objectID":"/docker%EB%9E%80/:3:0","tags":["Docker"],"title":"[Docker] Docker는 뭘까?","uri":"/docker%EB%9E%80/"},{"categories":["Docker"],"content":"Docker Install brew로 설치 virtualbox, vargrant 등 가상머신 위에 도커를 띄우는 작업 필요 compose, machine등 추가 설치 필요 서버 실행시 호스트 OS에서 서버 접근시 포트 포워딩 필요 brew cask로 설치 brew cask 는 Docker Desktop on Mac 도커를 설치해주며, docker-compose, docker-machine을 같이 설치 해줌 맥 OS에서 띄우기 때문에 가상 머신에서 포트 포워딩을 할 필요 없음 # 먼저 cask 먼저 설치 $ brew install cask # Docker Install $ brew install --cask docker 위와 같이 입력하면 docker는 정상적으로 잘 다운된다! ","date":"2023-03-17","objectID":"/docker%EB%9E%80/:4:0","tags":["Docker"],"title":"[Docker] Docker는 뭘까?","uri":"/docker%EB%9E%80/"},{"categories":["Docker"],"content":"MariaDB Install # Docker Image 받기 $ docker pull mariadb # mariadb 확인 $ docker images # MariaDB 컨테이너 실행 # (1) docker run : docker image에서 container를 생성 # (2) –name maria-db : maria-db라는 이름을 가진 컨테이너 생성 # (3) -p 3307:3306 : 해당 컨테이너의 포트 forwarding에 대해 inbound는 3307로 하고, # outbound는 3306으로 설정한다. # 외부에서 접속 시 3307 포트를 사용하여 컨테이너에 정보를 전달하면, 컨테이너는 내부적으로 3306 포트를 # 사용하여 처리하고 정보를 외부로 보낸다. mySQL에서도 MariaDB와 동일하게 3306 포트를 사용하기 때문. # (4) -e : 컨테이너 내 변수 설정 # (5) MYSQL_ROOT_PASSWORD=”암호” : ROOT 암호 설정 # (6) -d mariadb : mariadb라는 이미지에서 분리하여 컨테이너 생성 # (7) --lower_case_table_names=1 : 대소문자 구분을 제거해준다. $ docker run --name mariadb -p 3307:3306 -e MYSQL_ROOT_PASSWORD=1234 -d mariadb --lower_case_table_names=1 # 실행 중인 도커 확인 $ docker ps # 도커 명령어를 통해 DB 접속 $ docker exec -it mariadb mysql -u root -p 여기까지 잘 하셨으면 이제 local에서 세팅 가능합니다. 저는 DataGrip을 통해 연결해보도록 하겠습니다. ","date":"2023-03-17","objectID":"/docker%EB%9E%80/:5:0","tags":["Docker"],"title":"[Docker] Docker는 뭘까?","uri":"/docker%EB%9E%80/"},{"categories":["Docker"],"content":"DataGrip 연결 아래 순서대로 진행하면 연결 가능하다!!! ","date":"2023-03-17","objectID":"/docker%EB%9E%80/:6:0","tags":["Docker"],"title":"[Docker] Docker는 뭘까?","uri":"/docker%EB%9E%80/"},{"categories":["Docker"],"content":"포스트 작성 시 참고한 링크 도커란? Docker Install MariaDB Install ","date":"2023-03-17","objectID":"/docker%EB%9E%80/:7:0","tags":["Docker"],"title":"[Docker] Docker는 뭘까?","uri":"/docker%EB%9E%80/"},{"categories":["Git"],"content":" workflow는 어떤 것이 있고 어떤 방법론이 있는지 조사해보자고 마음을 먹어 작성하게되었다. ","date":"2023-03-05","objectID":"/workflow%EB%9E%80/:0:0","tags":["Git","workflow"],"title":"[Git] Workflow? 작업 방식?","uri":"/workflow%EB%9E%80/"},{"categories":["Git"],"content":"WorkFlow?? Git은 브랜치로 작업을 관리한다. 팀에서 브랜치를 어떻게 사용할 지에 대한 규칙을 Workflow라고 한다. Git에서 대표적인 Workflow는 Git flow, Github flow, Gitlab flow가 있다. ","date":"2023-03-05","objectID":"/workflow%EB%9E%80/:1:0","tags":["Git","workflow"],"title":"[Git] Workflow? 작업 방식?","uri":"/workflow%EB%9E%80/"},{"categories":["Git"],"content":"Git flow 브랜치의 역할이 명확하고 대규모 프로젝트에 적합. 2개의 메인 브랜치, 3개의 보조 브랜치로 나뉨. Main Branch master 제품으로 출시하는 브랜치 실제 배포 중이 상용 버전 develop 다음 출시 버전을 개발하는 브랜치 실제 작동 중인 버전의 다음 버전을 개발하기 위한 메인 스트림 Serve Branch feature 기능을 개발하는 브랜치 develop에서 뻗어 나와 develop으로 합쳐짐 실제 개발을 할때 가장 많이 쓰이는 브랜치 기능 별 브랜치 생성 후 개발 완료 시 develop 병합 자유로운 브랜치명, 서버에 올리지 않고 local에서 작업 release 새로운 버전을 배포하기 위한 브랜치(QA 용도) develop에서 뻗어나와 develop으로 합쳐지거나 배포 준비 완료 시 master로 합쳐짐 주로 버그를 수정하는 디버깅만 커밋 release-* 라는 이름을 사용 master에 병합했다면 develop에도 병합해 내용 일치시킴 hotfix 상용 제품에서 버그 발생 시 처리하는 브랜치 master에서 뻗어 나와 버그 수정 후 master와 develop으로 병합 버그 픽스를 위한 브랜치로 다버깅만 커밋하며, 보통 일회성 사용 작업 과정 개인 작업은 develop에서 feature 브랜치를 따서 작업한다. 개인 작업이 끝나면 develop에 병합한다. develop브랜치에서 배포 준비가 끝나면 release 브랜치로 분할한다. release 브랜치에서 디버깅하고 문제가 없으면 master와 develop 브랜치에 합친다. master브랜치를 배포한다. 만약 배포 버전에서 문제가 생겨 급하게 수정해야 하면 hotfix 브랜치를 따서 작업한다. hotfix에서 버그픽스가 끝나면 master와 develop에 합친다. Git flow ","date":"2023-03-05","objectID":"/workflow%EB%9E%80/:2:0","tags":["Git","workflow"],"title":"[Git] Workflow? 작업 방식?","uri":"/workflow%EB%9E%80/"},{"categories":["Git"],"content":"Github flow 하나의 메인 브랜치인 master 브랜치를 중점으로 운용하며 pull request을 활용한 방식 master 브랜치는 항상 최신 버전 유지 및 안정적이어야 함 브랜치의 용도가 명확하게 분류되어 있지 않아 브랜치 생성 시 브랜치 명을 명확하게 작성 일반적으로 feature 브랜치의 작업은 local 저장소가 아닌 원격 저장소에 저장 작업 과정 개인 작업은 feature 브랜치에서 작업하며 작업이 끝나면 pull request를 생성한다. pull request에서 코드 리뷰 후에 문제가 없으면 master로 병합한다. master에 병합하면 바로 배포 작업을 수행한다. (CI 자동화 권장) Github flow ","date":"2023-03-05","objectID":"/workflow%EB%9E%80/:3:0","tags":["Git","workflow"],"title":"[Git] Workflow? 작업 방식?","uri":"/workflow%EB%9E%80/"},{"categories":["Git"],"content":"Gitlab flow master, develop(production) 2개의 메인 브랜치로 관리 항상 최신 버전의 버전을 유지하지 않아도 됨 배포 버전과 개발 버전을 따로 둘 수 있다는 장점 develop 브랜치는 github flow의 develop브랜치와 같은 역할을 한다. master 브랜치는 배포 버전이다. 작업 과정 개인 개발은 feature 브랜치에서 작업하고 완료 시 merge develop 브랜치가 배포되기 적합하다고 판단되면 master브랜치로 merge한다. Gitlab flow ","date":"2023-03-05","objectID":"/workflow%EB%9E%80/:4:0","tags":["Git","workflow"],"title":"[Git] Workflow? 작업 방식?","uri":"/workflow%EB%9E%80/"},{"categories":["Git"],"content":"Centralized Workflow 단일 중앙 저장소를 사용하며 master 브랜치 하나만 사용 팀 구성원들은 중앙 저장소를 복제하여 로컬 저장소를 만들고, 변경 내용을 커밋하고 언제든 중앙 저장소와 동기화 진행 중앙 저장소의 커밋이 기준이 되므로, 변경 사항을 푸시할 때, 저장소의 커밋과 충돌난다면 Git은 푸시를 거부 이 때 중앙 저장소의 변경 내용을 가져와 자신의 변경 내용과 병합하거나 재배열하여 충돌 해결 후 푸시 작업 과정 중앙 저장소를 클론하려 로컬 저장소 생성 커밋 이력을 중앙 저장소에 푸시 다른 개발자가 중앙 저장소로 푸시할 때 최신 커밋을 반영되어 있지 않으면 푸시 거부 push 할 때는 항상 최신 커밋 이력을 포함해서 올려야함 Centralized Workflow 특징 Git에 특징인 분산 버전 관리의 이점을 사용할 수 없지만 최소한의 명령어로 협업 가능 Centralized Workflow ","date":"2023-03-05","objectID":"/workflow%EB%9E%80/:5:0","tags":["Git","workflow"],"title":"[Git] Workflow? 작업 방식?","uri":"/workflow%EB%9E%80/"},{"categories":["Git"],"content":"Feature Branch Workflow 기능 별 브랜치를 만들어 작업 하는 것 master 브랜치에 손대지 않기 때문에 다른 기능 브랜치를 얼마든지 올려도 된다. 이는 로컬 저장소 백업 역할 수행 master 브랜치는 항상 버그 프리 상태로 유지하며, 병합 시 권한을 가진 사용자가 pull request 적용 작업 과정 중앙 저장소를 클론한 로컬 저장소에 작업 브랜치 생성 작업 브랜치에서 작업 후 커밋 생성 및 원격 저장소로 푸시(브랜치와 같이) pull requst를 남겨 팀에게 작업 완료 사실을 알림 담당자가 작업 내용을 검증하고 수정이 필요하다 판단되면 해당 내역을 알려줌 해당 부분을 수정 후 푸시(pr은 다시 올리지 않아도 수정 내용이 전부 표시) 담당자가 검증 후 pr을 수용하기로 결정 되었다면 병합 진행(병함은 아무나 가능) Feature Branch Workflow 특징 브랜치를 이용하면 안전하게 새 기능을 개발 할 수 있을 뿐만 아니라, pull request를 이용해서 브랜치에 대한 팀 구성원들의 토론 참여를 이끌어냄 pull request는 코드 리뷰의 시작점 코드 리뷰를 진행하면 컨벤션을 맞출 수 있음 개발 중 막히는 부분이 pr을 통해 의견을 주고 받아 팀 구성원의 도움을 받을 수 있음. 큰 규모의 프로젝트를 관리할 때는 Gitflow Workflow를 사용해 기능 개발, 릴리스, 유지보수를 위해 좀 더 엄격한 워크플로우를 유지. Feature Branch Workflow ","date":"2023-03-05","objectID":"/workflow%EB%9E%80/:6:0","tags":["Git","workflow"],"title":"[Git] Workflow? 작업 방식?","uri":"/workflow%EB%9E%80/"},{"categories":["Git"],"content":"Forking Workflow 하나의 중앙 저장소를 이용하는 것이 아니라, 개개인마다 서로 다른 원격 저장소를 운영 자신의 원격 저장소에 푸시하고 그 내용을 공식 저장소의 프로젝트 관리자에게 풀 리퀘스트를 보냄 관리자는 공식 저장소에 푸시 권한을 주지 않고도 다른 개발자의 커밋을 수용 프로젝트와 직접 관련이 없는 제 3자뿐만 아니라, 아주 큰 규모의 분산된 팀에서도 안전하게 협업하기에 좋은 방법. 특히, 오픈소스 프로젝트에서 많이 사용하는 방식 작업 과정 공식 저장소를 fork해 나의 원격 저장소 생성 다른 개발자들은 나의 원격 저장소에 푸시 할 수 없음. fork한 원격 저장소를 clone해 작업 수행 내 원격 저장소에 push하고 작업분을 반영 할 수 있는 프로젝트 관리자에게 pr을 보냄. Forking Workflow 특징 다른 워크플로우에서는 공식 저장소에 브랜치를 푸시해서 팀 구성원들이 공유했다면, Forking Workflow에서는 나의 브랜치를 다른 참여자들이 자신의 로컬 저장소로 내려 받아 참고하고 병합 Forking Workflow ","date":"2023-03-05","objectID":"/workflow%EB%9E%80/:7:0","tags":["Git","workflow"],"title":"[Git] Workflow? 작업 방식?","uri":"/workflow%EB%9E%80/"},{"categories":["Git"],"content":"포스트 작성 시 참고한 링크 Git Workflow 다양한 Workflow centralized-workflow 이미지 feature-branch-workflow 이미지 forking-workflow ","date":"2023-03-05","objectID":"/workflow%EB%9E%80/:8:0","tags":["Git","workflow"],"title":"[Git] Workflow? 작업 방식?","uri":"/workflow%EB%9E%80/"},{"categories":["Git"],"content":" 프로그래밍을 공부 했을 시절 분기되었던 브랜치를 합치는 것 작업을 merge로 만 수행했었다. 현업에 들어오고 나서 git history가 엉망이 되어가는 것을 직접 목격하였다… 어떻게 해야 history를 잘 관리 할 수 있는지 궁금하였고 사수의 도움으로 rebase하는 것을 알게 되었다. rebase 를 알고 사용하고 있지만 merge와 rebase의 차이점을 명확하게 알고 싶어 찾아보았다. ","date":"2023-03-05","objectID":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/:0:0","tags":["Git","Merge","Rebase"],"title":"[Git] Merge와 Rebase 차이","uri":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/"},{"categories":["Git"],"content":"들어가기 앞서 merge와 rebase의 차이를 알아보기 전에 이것들은 어떤 상황에서 사용하며 사용하면 어떤 일이 일어나는지 부터 간단하게 알아보고자 한다. Git이란? 형상 관리 도구 중 하나이며 소스코드를 효과적으로 관리할 수 있게 해주는 공개 소프트웨어이다. branch란? Software 개발 시 다양한 개발자들이 동일한 프로젝트 위에서 개발, 유지보수 등의 업무를 하는 경우가 많다. 이때 하나의 프로젝트 에서 동시에 작업하게 되면 여러가지 문제가 발생한다. 이 것을 해결하기 위해 각각 완전히 독립된 브랜치 생성하여 동시에 코드 개발 및 수정 할 수 있게 도와준다. ","date":"2023-03-05","objectID":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/:1:0","tags":["Git","Merge","Rebase"],"title":"[Git] Merge와 Rebase 차이","uri":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/"},{"categories":["Git"],"content":"merge? rebase? merge는 분기된 branch를 다른 branch로 합치는 과정이고 rebase는 branch의 base를 옮긴다는 개념의 차이가 있다. ","date":"2023-03-05","objectID":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/:2:0","tags":["Git","Merge","Rebase"],"title":"[Git] Merge와 Rebase 차이","uri":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/"},{"categories":["Git"],"content":"merge와 rebase의 특징 merge 병합을 하면 합쳐진 브랜치의 커밋 메시지가 중복으로 쌓임. 커밋 순서를 변경되지 않음. 존재하는 브랜치가 변경되지 않음. 새로운 merge commit을 생성. git merge rebase 병합을 하면 브랜치의 커밋 메시지가 시간 순서대로 합침. 히스토리를 깔끔하게 유지하기 위해 사용. 분기된 브랜치를 마스터 브랜치 끝에 위치 시켜, master 브랜치를 재배치(rebase) 하는 것을 말함. 즉, rebase는 어떤 특정 브랜치의 커밋 이력을 base로 재정렬되면서 해쉬 ID가 바뀜 git rebase ","date":"2023-03-05","objectID":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/:3:0","tags":["Git","Merge","Rebase"],"title":"[Git] Merge와 Rebase 차이","uri":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/"},{"categories":["Git"],"content":"rebase를 사용하는 이유 하나의 프로젝트의 많은 개발자들이 활발하게 작업을 진행하게 되면 많은 브랜치가 생기고 master브랜치로 merge만 한다면 엄청나게 복잡한 git history를 볼 수 있을 것이다. rebase를 하여 작업 순서대로 history를 관리하고 불필요한 병합 커밋을 제거할 수 있다. merge와 rebase history 비교 ","date":"2023-03-05","objectID":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/:4:0","tags":["Git","Merge","Rebase"],"title":"[Git] Merge와 Rebase 차이","uri":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/"},{"categories":["Git"],"content":"rebase 사용 시 유의점 여러 사람이 사용하고 활발하게 커밋이 일어나는 브랜치라고 한다면, Rebase를 하는 것은 자칫 위험할 수 있습니다. 왜냐하면 파생된 브랜치에서 이미 새로운 커밋이 발생하고 작업이 기록되고 있는데 이전 기준 브랜치로 base를 변경해버리면 파생브랜치로 작업하고 있던 작업자들의 커밋 히스토리가 변경되어 버리기 때문입니다. 각 작업자들은 자신의 커밋을 다시 반영하거나 재작업을 해야 할 수도 있습니다. 따라서 혼자 작업하는 브랜치나 작업하는 사람이 적어 문제상황이 발생할 확률이 적은 경우에만 주의깊게 사용해야 합니다. ","date":"2023-03-05","objectID":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/:5:0","tags":["Git","Merge","Rebase"],"title":"[Git] Merge와 Rebase 차이","uri":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/"},{"categories":["Git"],"content":"포스트 작성 시 참고한 링크 merge와 rebase 차이 rebase 사용 시 유의사항 ","date":"2023-03-05","objectID":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/:6:0","tags":["Git","Merge","Rebase"],"title":"[Git] Merge와 Rebase 차이","uri":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/"},{"categories":["Git"],"content":"브랜치?? 여러 개발자들이 동시에 다양한 작업을 할 수 있게 만들어 주는 기능이 바로 브랜치(Branch) 이다. 각자 독립적인 작업 영역(저장소) 안에서 마음대로 소스코드를 변경할 수 있다. 이렇게 분리된 작업 영역에서 변경된 내용은 나중에 원래의 버전과 비교해서 하나의 새로운 버전으로 만들어 낼 수 있다. ","date":"2023-03-05","objectID":"/branch%EB%9E%80/:1:0","tags":["Git","Branch"],"title":"[Git] branch가 자세히 뭘까?","uri":"/branch%EB%9E%80/"},{"categories":["Git"],"content":"브랜치 사용법 메인 브랜치에서 자신의 작업 전용 브랜치를 만듦 각자 작업을 진행한 후, 작업이 끝난 사람은 메인 브랜치에 자신의 브랜치의 변경 사항을 적용 다른 사람의 작업에 영향을 받지 않고 독립적으로 특정 작업을 수행하고 그 결과를 하나로 모음 브랜치로 그 작업의 기록을 중간 중간에 남기게 되므로 문제가 발생했을 경우 원인이 되는 작업을 찾아내거나 그에 따른 대책을 세우기 쉬워짐 ","date":"2023-03-05","objectID":"/branch%EB%9E%80/:2:0","tags":["Git","Branch"],"title":"[Git] branch가 자세히 뭘까?","uri":"/branch%EB%9E%80/"},{"categories":["Git"],"content":"Code # 브랜치 생성 # git branch branchName $ git branch myWork-1 # 브랜치 이동 # switch 혹은 checkout 둘 다 가능 # git switch branchName $ git switch myWork-1 # 브랜치 생성 및 이동 # git checkout -b branch_name # git switch -c branch_name $ git switch -c myWork-2 # 현재 브랜치 확인 $ git branch # 브랜치 삭제 # git branch -d branchName $ git branch -d myWork-1 ","date":"2023-03-05","objectID":"/branch%EB%9E%80/:3:0","tags":["Git","Branch"],"title":"[Git] branch가 자세히 뭘까?","uri":"/branch%EB%9E%80/"},{"categories":["Git"],"content":"포스트 작성 시 참고한 링크 브랜치란? ","date":"2023-03-05","objectID":"/branch%EB%9E%80/:4:0","tags":["Git","Branch"],"title":"[Git] branch가 자세히 뭘까?","uri":"/branch%EB%9E%80/"},{"categories":["형상관리"],"content":" 현재 가장 많이 사용하고 있는 형상관리도구 git에 대해 공부를 하다가 문득 궁금한 것이 생겼다. Git은 형상관리 도구 중 하나인데 다른 형상관리도구랑 어떠한 차이가 있을까? 그래서 한번 각각의 형산관리 도구에 대해 알아보고 장단점은 무엇인지 알아보고자 한다. ","date":"2023-03-04","objectID":"/%ED%98%95%EC%83%81%EA%B4%80%EB%A6%AC%EB%9E%80/:0:0","tags":["형상관리","Git","SVN","CVS"],"title":"[형상관리] 형상관리란 SVN? GIT?","uri":"/%ED%98%95%EC%83%81%EA%B4%80%EB%A6%AC%EB%9E%80/"},{"categories":["형상관리"],"content":"형상관리?? 소프트웨어 구성 관리(Software Configuration Management) 또는 형상관리는 소프트웨어의 변경사항을 체계적으로 추적하고 통제 하는 것 일반적으로 단순 버전관리 기반의 소프트웨어 운용을 좀 더 포괄적인 학술 분야의 형태로 넓히는 근간 소프트웨어의 소스 코드, 개발 환경, 빌드 구조 등 전반적인 환경 전반적인 내역에 대한 관리 체계를 정의 형상 관리는 포괄적인 개념, 통상적으로 버전관리, 소스관리 등으로 불립니다. 즉, 정보를 여러 버전을 관리하는 것 ","date":"2023-03-04","objectID":"/%ED%98%95%EC%83%81%EA%B4%80%EB%A6%AC%EB%9E%80/:1:0","tags":["형상관리","Git","SVN","CVS"],"title":"[형상관리] 형상관리란 SVN? GIT?","uri":"/%ED%98%95%EC%83%81%EA%B4%80%EB%A6%AC%EB%9E%80/"},{"categories":["형상관리"],"content":"변경관리 / 버전관리 / 형상관리 변경관리, 버전관리, 형상관리. 표면적인 의미로 보면 거의 비슷하지만 이들은 제어 및 지원 범위에서 차이가 있다. 변경 관리 : 소스코드 변경 사항에 대한 관리 버전 관리 : 변경사항을 ‘버전’이란 개념을 통해 관리. 형상 관리 : 위의 개념을 포함해 프로젝트와 관련된 모든 변경사항을 관리. 포함관계를 포함하자면 변경관리 ⊆ 버전관리 ⊆ 형상관리 형상관리 3가지 버전 ","date":"2023-03-04","objectID":"/%ED%98%95%EC%83%81%EA%B4%80%EB%A6%AC%EB%9E%80/:2:0","tags":["형상관리","Git","SVN","CVS"],"title":"[형상관리] 형상관리란 SVN? GIT?","uri":"/%ED%98%95%EC%83%81%EA%B4%80%EB%A6%AC%EB%9E%80/"},{"categories":["형상관리"],"content":"버전 관리 시스템? 형상관리 중에서 문서, 소스코드 등을 버전을 관리해주는 버전관리시스템이다. 통상적으로 “형상관리 ≒ 버전관리” 임을 인지하고 접근하는 것이 이해하기 쉽다. ","date":"2023-03-04","objectID":"/%ED%98%95%EC%83%81%EA%B4%80%EB%A6%AC%EB%9E%80/:3:0","tags":["형상관리","Git","SVN","CVS"],"title":"[형상관리] 형상관리란 SVN? GIT?","uri":"/%ED%98%95%EC%83%81%EA%B4%80%EB%A6%AC%EB%9E%80/"},{"categories":["형상관리"],"content":"버전 관리(형상 관리)를 위한 도구와 특징 CVS(Concurrent Version System) 90년에 출시된 무료 서버-클라이언트 형상관리 시스템 파일 전체를 저장하는 것이 아니라 변경사항만을 저장 변경사항만 저장하기 때문에 용량을 적게 차지하지만 속도가 상대적으로 느림 Perforce(P4D) 빠른 속도, 빠른 Merge가 가능하며 큰 리소스 관리에 좋음 유료이고 파일명이 바뀌면 히스토리 추적이 곤란 SVN (Subversion) 형상관리/소스관리 툴의 일종 중앙관리만 지원 다른 사용자의 커밋과 엉키지 않으며, 커밋 실패 시 롤백 기능을 지원 Git 분산형 버전관리 시스템 Repository의 완전한 복사본을 로컬에 저장할 수 있음 처리속도가 빠르지만 대용량 코드 관리에 부적절 ","date":"2023-03-04","objectID":"/%ED%98%95%EC%83%81%EA%B4%80%EB%A6%AC%EB%9E%80/:4:0","tags":["형상관리","Git","SVN","CVS"],"title":"[형상관리] 형상관리란 SVN? GIT?","uri":"/%ED%98%95%EC%83%81%EA%B4%80%EB%A6%AC%EB%9E%80/"},{"categories":["형상관리"],"content":"가장 많이 사용하는 SVN과 Git 비교 SVN (Subversion) SVN은 보통 대부분의 기능을 완성해놓고 소스를 중앙 저장소에 commit commit의 이미 자체가 중앙 저장소에 해당 기능을 공개한다는 의미. 개발자가 자신만의 version history를 가질 수 없음. commit한 내용에 실수가 있을 시에 다른 개발자에게 바로 영향을 미치게 되는 단점도 있다. 저장소를 한개만 두는 것의 단점은 만약 데이터가 소실되었을때 복구가 어려움 Git 개발자가 자신만의 commit history를 가질 수 있고, 개발자와 서버의 저장소는 독립적으로 관리가 가능. commit한 내용에 실수가 있더라도 이 바로 서버에 영향을 미치지 않음. 개발자는 commit 하다가 자신이 원하는 순간에 서버에 변경 내역(commit history)을 보낼 수 있음. 서버의 통합 관리자는 관리자가 원하는 순간에 각 개발자의 commit history를 가져올 수 있음. ","date":"2023-03-04","objectID":"/%ED%98%95%EC%83%81%EA%B4%80%EB%A6%AC%EB%9E%80/:5:0","tags":["형상관리","Git","SVN","CVS"],"title":"[형상관리] 형상관리란 SVN? GIT?","uri":"/%ED%98%95%EC%83%81%EA%B4%80%EB%A6%AC%EB%9E%80/"},{"categories":["형상관리"],"content":"SVN과 Git 차이점 git은 로컬 저장소가 있으므로 네트워크에 접근할 필요가 없기 때문에 빠름. svn은 commit 하는 순간 저장소를 공유하는 모든 개발자들이 보게 된다. git은 내 로컬 저장소에서 마음껏 개발하고 정리하여 필요할 때 원격 저장소로 올림. git의 경우 원격 저장소 서버가 잠시 끊기더라도 버전 컨트롤이 가능 svn은 서버가 끊기는 순간 버전 컨트롤도 같이 끊김. 원격 저장소가 사라지면 svn은 복구 불가, git은 로컬 저장소에 사본을 들고 있다면 복구 가능. svn은 저장소가 하나, git은 로컬 저장소/원격 저장소로 저장소를 분산해서 관리 ","date":"2023-03-04","objectID":"/%ED%98%95%EC%83%81%EA%B4%80%EB%A6%AC%EB%9E%80/:6:0","tags":["형상관리","Git","SVN","CVS"],"title":"[형상관리] 형상관리란 SVN? GIT?","uri":"/%ED%98%95%EC%83%81%EA%B4%80%EB%A6%AC%EB%9E%80/"},{"categories":["형상관리"],"content":"포스트 작성 시 참고한 링크 형상관리란 - 1 형상관리란 - 2 SVN, GIT 차이점 ","date":"2023-03-04","objectID":"/%ED%98%95%EC%83%81%EA%B4%80%EB%A6%AC%EB%9E%80/:7:0","tags":["형상관리","Git","SVN","CVS"],"title":"[형상관리] 형상관리란 SVN? GIT?","uri":"/%ED%98%95%EC%83%81%EA%B4%80%EB%A6%AC%EB%9E%80/"},{"categories":["Blog"],"content":" 현업에서 일하기 시작한지 이제 3개월이 지나가고 있는 시점에 공부가 필요하다고 뼈저리게 느끼고 있습니다. 직장에 다니기 전에 네이버 블로그를 통해 배운 내용을 정리하였지만 조금 더 개발자스러운 블로그를 운영하고 싶다고 느껴 깃 블로그를 만들게 되었습니다. 시작하기 앞서 운영체제는 MAC에서 제작하였습니다. ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:0:0","tags":["Blog","GitBlog","Hugo"],"title":"[Blog] 깃 블로그 만드는 방법","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["Blog"],"content":"블로그 플랫폼 선택 블로그를 쓰려고 마음먹고 나서 플랫폼이 뭐가 있는지 찾아보면서 나한테 가장 잘 맞는 플랫폼은 뭐가 있을까? 많은 고민을 하던 중 가장 많이 사용되고 있는듯(?)한 플랫폼 3가지를 비교해 보았다. Jekyll Ruby 기반 GitHub Page에 최적화되어 있음 현재 가장 대중적으로 사용하는 플랫폼 한글 레퍼런스가 제일 많음 빌드를 진행하는데 너무 오래걸림 Hexo JS(Node.js) 기반 한글 레퍼런스 꽤 있음 마크다운 문서로 만든 포스팅을 하는 방법이 간단 Git으로 포스트 버전관리 불가능(두가지 브랜치로 관리) Hugo GoLang 기반 빌드가 빠름 문서화 잘되어 있음 한글 레퍼런스가 거의 없음 ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:1:0","tags":["Blog","GitBlog","Hugo"],"title":"[Blog] 깃 블로그 만드는 방법","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["Blog"],"content":"Hugo!! 너로 정했다!! 기존 네이버 블로그를 작성하면서 테마가 이쁘고 커스텀 할 수있는 요소가 많은 블로그를 만들고 싶었다. 테마가 마음에 들면서 기능이 많았으면 좋다고 생각했고 jekyll, hexo, hugo 중 빌드 속도가 제일 빠르고 Golang을 사용해 볼 수 있는 좋은 기회라는 생각이 들어 hugo를 선택하게 되었다. ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:2:0","tags":["Blog","GitBlog","Hugo"],"title":"[Blog] 깃 블로그 만드는 방법","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["Blog"],"content":"기본 환경 세팅 HomeBrew 설치 터미널에 아래 코드를 입력해주면 다운로드가 완료 된다! /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" Github 회원가입 순서대로 진행해주면 가입된다! 또는 포털 사이트에서 github 입력 후 오른쪽 상단 sing-in을 누르면 위 링크와 같이 가입할 수 있다! Git Downloads 홈페이지에 방문해 운영체제에 맡게 다운받아준다! Golang 설치 필자는 install을 통해 Golang을 다운했다 pakege-version : go1.20.1.darwin-amd64.pkg ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:3:0","tags":["Blog","GitBlog","Hugo"],"title":"[Blog] 깃 블로그 만드는 방법","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["Blog"],"content":"Hugo 설치 터미널에 다음과 같이 입력한다. # hugo 설치 $ brew install hugo # hugo version 확인 $ hugo version # 다음과 같이 뜨면 정상적으로 설치가 완료 된 것이다. hugo v0.110.0+extended darwin/amd64 BuildDate=unknown # 만약 brew link 에러가 발생한다면 brew에 권한을 설정해줘야함 $ sudo chown -R $(whoami) $(brew --prefix)/* ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:4:0","tags":["Blog","GitBlog","Hugo"],"title":"[Blog] 깃 블로그 만드는 방법","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["Blog"],"content":"Github repository 생성 2개의 레포지토리를 만들어야한다. ex) blog, \u003cusername\u003e.github.io 내가 만든 레포지토리 blog, choiseungWoo98.github.io ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:5:0","tags":["Blog","GitBlog","Hugo"],"title":"[Blog] 깃 블로그 만드는 방법","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["Blog"],"content":"Hugo로 프로젝트 생성 내가 따로 프로젝트를 만들지 않아도 hugo가 알아서 만들어 준다. 간편해..👍🏻 # hugo 프로젝트 생성 $ hugo new site blog # 생성 완료되면 출력 문구 Congratulations! Your new Hugo site is created in /Users/username/folder/blog. Just a few more steps and you're ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \"hugo new theme \u003cTHEMENAME\u003e\" command. 2. Perhaps you want to add some content. You can add single files with \"hugo new \u003cSECTIONNAME\u003e/\u003cFILENAME\u003e.\u003cFORMAT\u003e\". 3. Start the built-in live server via \"hugo server\". Visit https://gohugo.io/ for quickstart guide and full documentation. ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:6:0","tags":["Blog","GitBlog","Hugo"],"title":"[Blog] 깃 블로그 만드는 방법","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["Blog"],"content":"테마 설정 테마는 직접 만들 수 있다고 한다. 하지만 저는.. 기존 공개된 테마 중 가장 마음에 드는거로 사용하려한다. 원하는 테마를 선택했다면 아까 다운받은 프로젝트에 적용시켜 주자! 필자는 LoveIt테마를 사용하였다!! 해당 사이트 이동 후 Download를 누르면 Github 페이지로 이동한다. 오른쪽 초록색 Code를 클릭 후 링크를 복사하자! # 현재 경로 확인 $ pwd # 프로젝트 경로로 이동 보통 유저 정보는 default로 설정되어 있다. 나갈때는 cd .. $ cd blog # 프로젝트 폴더에 들어왔는지 확인 $ pwd # 잘 들어왔으면 아래와 같이 출력된다. # /Users/\u003cusername\u003e/blog # git 저장소로 사용하기 위한 git 명령어 $ git init # git branch 명을 변경하려면 사용해주면 된다 나는 master가 아닌 main으로 사용하고 있다. $ git branch -M main # 아까 사용하려고 했던 테마의 깃 주소를 복사해 아래와 같이 작성해주면 테마가 다운로드 된다. # git submodule add \u003c복사한 테마 주소\u003e themes/\u003c테마 이름\u003e $ git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt # blog 폴더 내부에 있는 config.toml을 다운받은 테마에 맞게 수정해준다 # 기존에 config.toml # baseURL = 'http://example.org/' # languageCode = 'en-us' # title = 'My New Hugo Site' # cp themes/\u003c위에서 설정한 테마 이름\u003e/exampleSite/config.toml config.toml $ cp themes/LoveIt/exampleSite/config.toml config.toml 이후 config.toml을 자신의 맞게 수정하면 된다. baseURL은 반드시 수정해야함! 블로그 커스텀은 추후에 한번에 다루겠습니다! 위에서 설정한 Repository name을 baseURL에 작성 ex) baseURL = \"https://ChoiSeungWoo98.github.io/\" baseURL = \"https://\u003cusername\u003e.github.io/\" 다 설정했다면 로컬에서 테스트 해보자! $ hugo server 성공하면 아래와 같은 화면을 볼 수 있다. http://localhost:1313 접속하여 확인 에러 로그 Error: module \"LoveIt\" not found; either add it as a Hugo Module or store it in \"/Users/\".: module does not exist 해당 로그가 뜬다면 themes 폴더 내부에 LoveIt이 없다는 소리다 확인 후 config.toml에서 themes = \"폴더명\" 으로 바꿔주자! Error: module \"test\" not found; either add it as a Hugo Module or store it in \"/Users/\".: module does not exist test 폴더를 찾을 수 없다는 에러이다. 현재 LoveIt테마는 directory 주소를 설정 해주고 있다 이것을 제거해주자! config.toml 에서 아래 부분을 찾아서 제거 themes directory 主题目录 themesDir = \"../..\" PC 이미지 mobile 이미지 ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:7:0","tags":["Blog","GitBlog","Hugo"],"title":"[Blog] 깃 블로그 만드는 방법","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["Blog"],"content":"Git Repository 연결 여태까지 노력해서 만든 블로그를 git이랑 연동해보자! # blog -\u003e blog 레포지토리 연결 # git remote add origin http://github.com/\u003cusername\u003e/blog.git $ git remote add origin https://github.com/choiseungwoo98/blog.git # blog/public -\u003e \u003cusername\u003e.github.io 연결 # 아래 코드를 수행하기 전에 blog 폴더에 public이 없는지 확인하자! 있으면 오류가 발생한다.... # git submodule add -b main http://github.com/\u003cusername\u003e/\u003cusername\u003e.github.io.git public # 만약 기존에 등록한 것이 있다면 git rm -r --cached public 를 입력해서 제거 후 등록 # 그래도 안된다면 강제로 하자.. # git submodule add -b main --force https://github.com/ChoiSeungWoo98/ChoiSeungWoo98.github.io.git public $ git submodule add -b main https://github.com/ChoiSeungWoo98/ChoiSeungWoo98.github.io.git public ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:8:0","tags":["Blog","GitBlog","Hugo"],"title":"[Blog] 깃 블로그 만드는 방법","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["Blog"],"content":"게시글 작성 새로운 포스트를 만드는 것도 hugo에서 수행해준다.. hugo 짱.. # 아래 명령어를 입력하면 blog/content/posts/firstPost/test.md가 생성된다. 그걸 수정해서 글을 작성하면 된다! # hugo new posts/\u003c원하는 패쓰\u003e/파일 이름.md $ hugo new posts/firstPost/test.md Content \"/Users/user/workspace/blog/content/posts/firstPost/test.md\" created # 이제 게시글을 로컬에서 확인해보자! # 로컬 서버 실행 # draft: true로 설정 되어 있을때 hugo server로 실행하면 게시물이 보이지 않는다. # 따라서 아래 명령어로 서버를 실행해준다. 혹은 그냥 false로 두면 보임 # draft는 수정 중일때 true 수정 끝나면 false로 바꾸어야 github에 올라간다.. # http://localhost:1313 접속하여 확인 # 서버를 닫기 위해서는 ctrl + c 를 입력한다. $ hugo server -D ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:9:0","tags":["Blog","GitBlog","Hugo"],"title":"[Blog] 깃 블로그 만드는 방법","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["Blog"],"content":"드디어 배포!!! 이제 배포만 하면 깃 블로그가 생성된다!! 배포를 진행해보자! 배포하지 않으면 여태 까지 한 작업 다 필요 없다는건 안 비밀.. # 작성한 프로젝트 빌드하기 # hugo -t \u003c여러분의 테마\u003e $ hugo -t loveit # 빌드가 완료되면 public에 파일들이 생긴다. 이 부분은 위에 submodule로 나눠서 관리 하기 때문에 # 해당 폴더로 이동 후 배포해줘야함.. $ cd public # 변경된 모든 파일 추가하기 $ git add . # 커밋 남기기! # 아래 코드로 커밋을 남기면 현재 시간 기준으로 커밋 메세지가 담김 꼭 이렇게 안해줘도 됨! $ msg=\"rebuilding site `date`\" if [ $# -eq 1 ] then msg=\"$1\" fi git commit -m \"$msg\" # 현재 폴더 상태 확인하기 $ git status # 상태 확인하고 깨끗 하다면 커밋한 파일 배포해주기! $ git push origin main # blog 폴더로 이동하기 $ cd .. # blog 변경 사항 추가. public에서 배포한 부분도 여기서 다시 추가해줌 git add . # 추가한 사항 커밋 $ msg=\"rebuilding site `date`\" if [ $# -eq 1 ] then msg=\"$1\" fi git commit -m \"$msg\" # blog 배포하기 $ git push origin main 배포가 완료 되었다면 git repository에서 build되는 과정을 확인하고 오류 없이 성공했다면 본인 블로그에 들어가서 확인 할 수 있다! 블로그 주소 확인하기 블로그 주소를 모르겠다면 1. username.github.io 레포지토리를 들어가기 2. Settings에 들어가기 3. Pages로 이동 후 4. Visit site에서 확인 할 수 있다. 보통 \"https://username.github.io/ 이러한 주소일 것이다. 드디어 내 블로그 완성!! 예쁘게 꾸미고 싶은 욕심이 많이 있기 때문에 추후에 커스텀 포스트로 찾아뵙겠습니다!! 😄 ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:10:0","tags":["Blog","GitBlog","Hugo"],"title":"[Blog] 깃 블로그 만드는 방법","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["Blog"],"content":"포스트 작성 시 참고한 링크 정적 페이지 vs 동적 페이지 및 정적 페이지 비교 Hugo를 사용한 깃 블로그 만들기 ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:11:0","tags":["Blog","GitBlog","Hugo"],"title":"[Blog] 깃 블로그 만드는 방법","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":null,"content":"About","date":"2023-03-02","objectID":"/about/about/","tags":null,"title":"About","uri":"/about/about/"},{"categories":null,"content":"👋Introduction 🧑🏻‍💻 아직 배울게 많은 주니어 백엔드 엔지니어입니다. 👍 사용자 중심의 서비스에 관심이 많습니다. ✏️ 많은 것을 배우기 위해 열심히 노력중입니다. ","date":"2023-03-02","objectID":"/about/about/:1:0","tags":null,"title":"About","uri":"/about/about/"},{"categories":null,"content":"⚒️Stack⚒️ BackEnd DataBase FrontEnd SVN Blog ","date":"2023-03-02","objectID":"/about/about/:2:0","tags":null,"title":"About","uri":"/about/about/"},{"categories":null,"content":"✉️Contact ","date":"2023-03-02","objectID":"/about/about/:3:0","tags":null,"title":"About","uri":"/about/about/"},{"categories":["Diary"],"content":"처음 써보는 깃 블로그 게시글 입니다. 저는 이제 현업 3개월차 주주주주주주주주주주주니어 백엔드 개발자 입니다. :) 블로그를 쓰려고 다짐한 이유는 제가 느끼는 것들과 공부한 부분을 글로 적고 제 방식대로 이해하고 공부하기 위해 블로그를 작성 하자고 다짐하였습니다. 앞으로 꾸준하고 열심히 적고 배우는 개발자가 되도록 노력하겠습니다. 절대 이 마음 변치 않고 발전하는 개발자가 될 수 있도록!! 화이팅!!!!!! ","date":"2023-03-01","objectID":"/first-posts/:0:0","tags":["Diary","Jounal"],"title":"[Diary] 깃 블로그를 작성하기 전 다짐","uri":"/first-posts/"}]