[{"categories":["Git"],"content":" workflow는 어떤 것이 있고 어떤 방법론이 있는지 조사해보자고 마음을 먹어 작성하게되었다. ","date":"2023-03-05","objectID":"/workflow%EB%9E%80/:0:0","tags":["Git","workflow"],"title":"Workflow란?","uri":"/workflow%EB%9E%80/"},{"categories":["Git"],"content":"WorkFlow란? Git은 브랜치로 작업을 관리한다. 팀에서 브랜치를 어떻게 사용할 지에 대한 규칙을 Workflow라고 한다. Git에서 대표적인 Workflow는 Git flow, Github flow, Gitlab flow가 있다. ","date":"2023-03-05","objectID":"/workflow%EB%9E%80/:1:0","tags":["Git","workflow"],"title":"Workflow란?","uri":"/workflow%EB%9E%80/"},{"categories":["Git"],"content":"Git flow 브랜치의 역할이 명확하고 대규모 프로젝트에 적합. 2개의 메인 브랜치, 3개의 보조 브랜치로 나뉨. Main Branch master 제품으로 출시하는 브랜치 실제 배포 중이 상용 버전 develop 다음 출시 버전을 개발하는 브랜치 실제 작동 중인 버전의 다음 버전을 개발하기 위한 메인 스트림 Serve Branch feature 기능을 개발하는 브랜치 develop에서 뻗어 나와 develop으로 합쳐짐 실제 개발을 할때 가장 많이 쓰이는 브랜치 기능 별 브랜치 생성 후 개발 완료 시 develop 병합 자유로운 브랜치명, 서버에 올리지 않고 local에서 작업 release 새로운 버전을 배포하기 위한 브랜치(QA 용도) develop에서 뻗어나와 develop으로 합쳐지거나 배포 준비 완료 시 master로 합쳐짐 주로 버그를 수정하는 디버깅만 커밋 release-* 라는 이름을 사용 master에 병합했다면 develop에도 병합해 내용 일치시킴 hotfix 상용 제품에서 버그 발생 시 처리하는 브랜치 master에서 뻗어 나와 버그 수정 후 master와 develop으로 병합 버그 픽스를 위한 브랜치로 다버깅만 커밋하며, 보통 일회성 사용 작업 과정 개인 작업은 develop에서 feature 브랜치를 따서 작업한다. 개인 작업이 끝나면 develop에 병합한다. develop브랜치에서 배포 준비가 끝나면 release 브랜치로 분할한다. release 브랜치에서 디버깅하고 문제가 없으면 master와 develop 브랜치에 합친다. master브랜치를 배포한다. 만약 배포 버전에서 문제가 생겨 급하게 수정해야 하면 hotfix 브랜치를 따서 작업한다. hotfix에서 버그픽스가 끝나면 master와 develop에 합친다. Git flow ","date":"2023-03-05","objectID":"/workflow%EB%9E%80/:2:0","tags":["Git","workflow"],"title":"Workflow란?","uri":"/workflow%EB%9E%80/"},{"categories":["Git"],"content":"Github flow 하나의 메인 브랜치인 master 브랜치를 중점으로 운용하며 pull request을 활용한 방식 master 브랜치는 항상 최신 버전 유지 및 안정적이어야 함 브랜치의 용도가 명확하게 분류되어 있지 않아 브랜치 생성 시 브랜치 명을 명확하게 작성 일반적으로 feature 브랜치의 작업은 local 저장소가 아닌 원격 저장소에 저장 작업 과정 개인 작업은 feature 브랜치에서 작업하며 작업이 끝나면 pull request를 생성한다. pull request에서 코드 리뷰 후에 문제가 없으면 master로 병합한다. master에 병합하면 바로 배포 작업을 수행한다. (CI 자동화 권장) Github flow ","date":"2023-03-05","objectID":"/workflow%EB%9E%80/:3:0","tags":["Git","workflow"],"title":"Workflow란?","uri":"/workflow%EB%9E%80/"},{"categories":["Git"],"content":"Gitlab flow master, develop(production) 2개의 메인 브랜치로 관리 항상 최신 버전의 버전을 유지하지 않아도 됨 배포 버전과 개발 버전을 따로 둘 수 있다는 장점 develop 브랜치는 github flow의 develop브랜치와 같은 역할을 한다. master 브랜치는 배포 버전이다. 작업 과정 개인 개발은 feature 브랜치에서 작업하고 완료 시 merge develop 브랜치가 배포되기 적합하다고 판단되면 master브랜치로 merge한다. Gitlab flow ","date":"2023-03-05","objectID":"/workflow%EB%9E%80/:4:0","tags":["Git","workflow"],"title":"Workflow란?","uri":"/workflow%EB%9E%80/"},{"categories":["Git"],"content":"포스트 작성 시 참고한 링크 Git Workflow ","date":"2023-03-05","objectID":"/workflow%EB%9E%80/:5:0","tags":["Git","workflow"],"title":"Workflow란?","uri":"/workflow%EB%9E%80/"},{"categories":["Git"],"content":" 프로그래밍을 공부 했을 시절 분기되었던 브랜치를 합치는 것 작업을 merge로 만 수행했었다. 현업에 들어오고 나서 git history가 엉망이 되어가는 것을 직접 목격하였다… 어떻게 해야 history를 잘 관리 할 수 있는지 궁금하였고 사수의 도움으로 rebase하는 것을 알게 되었다. rebase 를 알고 사용하고 있지만 merge와 rebase의 차이점을 명확하게 알고 싶어 찾아보았다. ","date":"2023-03-05","objectID":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/:0:0","tags":["Git","Merge","Rebase"],"title":"Merge와 Rebase","uri":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/"},{"categories":["Git"],"content":"들어가기 앞서 merge와 rebase의 차이를 알아보기 전에 이것들은 어떤 상황에서 사용하며 사용하면 어떤 일이 일어나는지 부터 간단하게 알아보고자 한다. Git이란? 형상 관리 도구 중 하나이며 소스코드를 효과적으로 관리할 수 있게 해주는 공개 소프트웨어이다. branch란? Software 개발 시 다양한 개발자들이 동일한 프로젝트 위에서 개발, 유지보수 등의 업무를 하는 경우가 많다. 이때 하나의 프로젝트 에서 동시에 작업하게 되면 여러가지 문제가 발생한다. 이 것을 해결하기 위해 각각 완전히 독립된 브랜치 생성하여 동시에 코드 개발 및 수정 할 수 있게 도와준다. ","date":"2023-03-05","objectID":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/:1:0","tags":["Git","Merge","Rebase"],"title":"Merge와 Rebase","uri":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/"},{"categories":["Git"],"content":"merge? rebase? merge는 분기된 branch를 다른 branch로 합치는 과정이고 rebase는 branch의 base를 옮긴다는 개념의 차이가 있다. ","date":"2023-03-05","objectID":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/:2:0","tags":["Git","Merge","Rebase"],"title":"Merge와 Rebase","uri":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/"},{"categories":["Git"],"content":"merge와 rebase의 특징 merge 병합을 하면 합쳐진 브랜치의 커밋 메시지가 중복으로 쌓임. 커밋 순서를 변경되지 않음. 존재하는 브랜치가 변경되지 않음. 새로운 merge commit을 생성. git merge rebase 병합을 하면 브랜치의 커밋 메시지가 시간 순서대로 합침. 히스토리를 깔끔하게 유지하기 위해 사용. 분기된 브랜치를 마스터 브랜치 끝에 위치 시켜, master 브랜치를 재배치(rebase) 하는 것을 말함. 즉, rebase는 어떤 특정 브랜치의 커밋 이력을 base로 재정렬되면서 해쉬 ID가 바뀜 git rebase ","date":"2023-03-05","objectID":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/:3:0","tags":["Git","Merge","Rebase"],"title":"Merge와 Rebase","uri":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/"},{"categories":["Git"],"content":"rebase를 사용하는 이유 하나의 프로젝트의 많은 개발자들이 활발하게 작업을 진행하게 되면 많은 브랜치가 생기고 master브랜치로 merge만 한다면 엄청나게 복잡한 git history를 볼 수 있을 것이다. rebase를 하여 작업 순서대로 history를 관리하고 불필요한 병합 커밋을 제거할 수 있다. merge와 rebase history 비교 ","date":"2023-03-05","objectID":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/:4:0","tags":["Git","Merge","Rebase"],"title":"Merge와 Rebase","uri":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/"},{"categories":["Git"],"content":"rebase 사용 시 유의점 여러 사람이 사용하고 활발하게 커밋이 일어나는 브랜치라고 한다면, Rebase를 하는 것은 자칫 위험할 수 있습니다. 왜냐하면 파생된 브랜치에서 이미 새로운 커밋이 발생하고 작업이 기록되고 있는데 이전 기준 브랜치로 base를 변경해버리면 파생브랜치로 작업하고 있던 작업자들의 커밋 히스토리가 변경되어 버리기 때문입니다. 각 작업자들은 자신의 커밋을 다시 반영하거나 재작업을 해야 할 수도 있습니다. 따라서 혼자 작업하는 브랜치나 작업하는 사람이 적어 문제상황이 발생할 확률이 적은 경우에만 주의깊게 사용해야 합니다. ","date":"2023-03-05","objectID":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/:5:0","tags":["Git","Merge","Rebase"],"title":"Merge와 Rebase","uri":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/"},{"categories":["Git"],"content":"포스트 작성 시 참고한 링크 merge와 rebase 차이 rebase 사용 시 유의사항 ","date":"2023-03-05","objectID":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/:6:0","tags":["Git","Merge","Rebase"],"title":"Merge와 Rebase","uri":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/"},{"categories":["Git"],"content":"브랜치란? 여러 개발자들이 동시에 다양한 작업을 할 수 있게 만들어 주는 기능이 바로 브랜치(Branch) 이다. 각자 독립적인 작업 영역(저장소) 안에서 마음대로 소스코드를 변경할 수 있다. 이렇게 분리된 작업 영역에서 변경된 내용은 나중에 원래의 버전과 비교해서 하나의 새로운 버전으로 만들어 낼 수 있다. ","date":"2023-03-05","objectID":"/branch%EB%9E%80/:1:0","tags":["Git","Branch"],"title":"branch란?","uri":"/branch%EB%9E%80/"},{"categories":["Git"],"content":"브랜치 사용법 메인 브랜치에서 자신의 작업 전용 브랜치를 만듦 각자 작업을 진행한 후, 작업이 끝난 사람은 메인 브랜치에 자신의 브랜치의 변경 사항을 적용 다른 사람의 작업에 영향을 받지 않고 독립적으로 특정 작업을 수행하고 그 결과를 하나로 모음 브랜치로 그 작업의 기록을 중간 중간에 남기게 되므로 문제가 발생했을 경우 원인이 되는 작업을 찾아내거나 그에 따른 대책을 세우기 쉬워짐 ","date":"2023-03-05","objectID":"/branch%EB%9E%80/:2:0","tags":["Git","Branch"],"title":"branch란?","uri":"/branch%EB%9E%80/"},{"categories":["Git"],"content":"Code # 브랜치 생성 # git branch branchName $ git branch myWork-1 # 브랜치 이동 # switch 혹은 checkout 둘 다 가능 # git switch branchName $ git switch myWork-1 # 브랜치 생성 및 이동 # git checkout -b branch_name # git switch -c branch_name $ git switch -c myWork-2 # 현재 브랜치 확인 $ git branch # 브랜치 삭제 # git branch -d branchName $ git branch -d myWork-1 ","date":"2023-03-05","objectID":"/branch%EB%9E%80/:3:0","tags":["Git","Branch"],"title":"branch란?","uri":"/branch%EB%9E%80/"},{"categories":["Git"],"content":"포스트 작성 시 참고한 링크 브랜치란? ","date":"2023-03-05","objectID":"/branch%EB%9E%80/:4:0","tags":["Git","Branch"],"title":"branch란?","uri":"/branch%EB%9E%80/"},{"categories":["형상관리"],"content":" 현재 가장 많이 사용하고 있는 형상관리도구 git에 대해 공부를 하다가 문득 궁금한 것이 생겼다. Git은 형상관리 도구 중 하나인데 다른 형상관리도구랑 어떠한 차이가 있을까? 그래서 한번 각각의 형산관리 도구에 대해 알아보고 장단점은 무엇인지 알아보고자 한다. ","date":"2023-03-04","objectID":"/%ED%98%95%EC%82%B0%EA%B4%80%EB%A6%AC%EB%9E%80/:0:0","tags":["형상관리","Git","SVN","CVS"],"title":"형산관리란?","uri":"/%ED%98%95%EC%82%B0%EA%B4%80%EB%A6%AC%EB%9E%80/"},{"categories":["형상관리"],"content":"형상관리란 소프트웨어 구성 관리(Software Configuration Management) 또는 형상관리는 소프트웨어의 변경사항을 체계적으로 추적하고 통제 하는 것 일반적으로 단순 버전관리 기반의 소프트웨어 운용을 좀 더 포괄적인 학술 분야의 형태로 넓히는 근간 소프트웨어의 소스 코드, 개발 환경, 빌드 구조 등 전반적인 환경 전반적인 내역에 대한 관리 체계를 정의 형상 관리는 포괄적인 개념, 통상적으로 버전관리, 소스관리 등으로 불립니다. 즉, 정보를 여러 버전을 관리하는 것 ","date":"2023-03-04","objectID":"/%ED%98%95%EC%82%B0%EA%B4%80%EB%A6%AC%EB%9E%80/:1:0","tags":["형상관리","Git","SVN","CVS"],"title":"형산관리란?","uri":"/%ED%98%95%EC%82%B0%EA%B4%80%EB%A6%AC%EB%9E%80/"},{"categories":["형상관리"],"content":"변경관리 / 버전관리 / 형상관리 변경관리, 버전관리, 형상관리. 표면적인 의미로 보면 거의 비슷하지만 이들은 제어 및 지원 범위에서 차이가 있다. 변경 관리 : 소스코드 변경 사항에 대한 관리 버전 관리 : 변경사항을 ‘버전’이란 개념을 통해 관리. 형상 관리 : 위의 개념을 포함해 프로젝트와 관련된 모든 변경사항을 관리. 포함관계를 포함하자면 변경관리 ⊆ 버전관리 ⊆ 형상관리 형상관리 3가지 버전 사진 ","date":"2023-03-04","objectID":"/%ED%98%95%EC%82%B0%EA%B4%80%EB%A6%AC%EB%9E%80/:2:0","tags":["형상관리","Git","SVN","CVS"],"title":"형산관리란?","uri":"/%ED%98%95%EC%82%B0%EA%B4%80%EB%A6%AC%EB%9E%80/"},{"categories":["형상관리"],"content":"버전 관리 시스템? 형상관리 중에서 문서, 소스코드 등을 버전을 관리해주는 버전관리시스템이다. 통상적으로 “형상관리 ≒ 버전관리” 임을 인지하고 접근하는 것이 이해하기 쉽다. ","date":"2023-03-04","objectID":"/%ED%98%95%EC%82%B0%EA%B4%80%EB%A6%AC%EB%9E%80/:3:0","tags":["형상관리","Git","SVN","CVS"],"title":"형산관리란?","uri":"/%ED%98%95%EC%82%B0%EA%B4%80%EB%A6%AC%EB%9E%80/"},{"categories":["형상관리"],"content":"버전 관리(형상 관리)를 위한 도구와 특징 CVS(Concurrent Version System) 90년에 출시된 무료 서버-클라이언트 형상관리 시스템 파일 전체를 저장하는 것이 아니라 변경사항만을 저장 변경사항만 저장하기 때문에 용량을 적게 차지하지만 속도가 상대적으로 느림 Perforce(P4D) 빠른 속도, 빠른 Merge가 가능하며 큰 리소스 관리에 좋음 유료이고 파일명이 바뀌면 히스토리 추적이 곤란 SVN (Subversion) 형상관리/소스관리 툴의 일종 중앙관리만 지원 다른 사용자의 커밋과 엉키지 않으며, 커밋 실패 시 롤백 기능을 지원 Git 분산형 버전관리 시스템 Repository의 완전한 복사본을 로컬에 저장할 수 있음 처리속도가 빠르지만 대용량 코드 관리에 부적절 ","date":"2023-03-04","objectID":"/%ED%98%95%EC%82%B0%EA%B4%80%EB%A6%AC%EB%9E%80/:4:0","tags":["형상관리","Git","SVN","CVS"],"title":"형산관리란?","uri":"/%ED%98%95%EC%82%B0%EA%B4%80%EB%A6%AC%EB%9E%80/"},{"categories":["형상관리"],"content":"가장 많이 사용하는 SVN과 Git 비교 SVN (Subversion) SVN은 보통 대부분의 기능을 완성해놓고 소스를 중앙 저장소에 commit commit의 이미 자체가 중앙 저장소에 해당 기능을 공개한다는 의미. 개발자가 자신만의 version history를 가질 수 없음. commit한 내용에 실수가 있을 시에 다른 개발자에게 바로 영향을 미치게 되는 단점도 있다. 저장소를 한개만 두는 것의 단점은 만약 데이터가 소실되었을때 복구가 어려움 Git 개발자가 자신만의 commit history를 가질 수 있고, 개발자와 서버의 저장소는 독립적으로 관리가 가능. commit한 내용에 실수가 있더라도 이 바로 서버에 영향을 미치지 않음. 개발자는 commit 하다가 자신이 원하는 순간에 서버에 변경 내역(commit history)을 보낼 수 있음. 서버의 통합 관리자는 관리자가 원하는 순간에 각 개발자의 commit history를 가져올 수 있음. ","date":"2023-03-04","objectID":"/%ED%98%95%EC%82%B0%EA%B4%80%EB%A6%AC%EB%9E%80/:5:0","tags":["형상관리","Git","SVN","CVS"],"title":"형산관리란?","uri":"/%ED%98%95%EC%82%B0%EA%B4%80%EB%A6%AC%EB%9E%80/"},{"categories":["형상관리"],"content":"SVN과 Git 차이점 git은 로컬 저장소가 있으므로 네트워크에 접근할 필요가 없기 때문에 빠름. svn은 commit 하는 순간 저장소를 공유하는 모든 개발자들이 보게 된다. git은 내 로컬 저장소에서 마음껏 개발하고 정리하여 필요할 때 원격 저장소로 올림. git의 경우 원격 저장소 서버가 잠시 끊기더라도 버전 컨트롤이 가능 svn은 서버가 끊기는 순간 버전 컨트롤도 같이 끊김. 원격 저장소가 사라지면 svn은 복구 불가, git은 로컬 저장소에 사본을 들고 있다면 복구 가능. svn은 저장소가 하나, git은 로컬 저장소/원격 저장소로 저장소를 분산해서 관리 ","date":"2023-03-04","objectID":"/%ED%98%95%EC%82%B0%EA%B4%80%EB%A6%AC%EB%9E%80/:6:0","tags":["형상관리","Git","SVN","CVS"],"title":"형산관리란?","uri":"/%ED%98%95%EC%82%B0%EA%B4%80%EB%A6%AC%EB%9E%80/"},{"categories":["형상관리"],"content":"포스트 작성 시 참고한 링크 형상관리란 - 1 형상관리란 - 2 SVN, GIT 차이점 ","date":"2023-03-04","objectID":"/%ED%98%95%EC%82%B0%EA%B4%80%EB%A6%AC%EB%9E%80/:7:0","tags":["형상관리","Git","SVN","CVS"],"title":"형산관리란?","uri":"/%ED%98%95%EC%82%B0%EA%B4%80%EB%A6%AC%EB%9E%80/"},{"categories":["Blog"],"content":" 현업에서 일하기 시작한지 이제 3개월이 지나가고 있는 시점에 공부가 필요하다고 뼈저리게 느끼고 있습니다. 직장에 다니기 전에 네이버 블로그를 통해 배운 내용을 정리하였지만 조금 더 개발자스러운 블로그를 운영하고 싶다고 느껴 깃 블로그를 만들게 되었습니다. 시작하기 앞서 운영체제는 MAC에서 제작하였습니다. ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:0:0","tags":["Blog","GitBlog","Hugo"],"title":"깃 블로그 만들기","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["Blog"],"content":"블로그 플랫폼 선택 블로그를 쓰려고 마음먹고 나서 플랫폼이 뭐가 있는지 찾아보면서 나한테 가장 잘 맞는 플랫폼은 뭐가 있을까? 많은 고민을 하던 중 가장 많이 사용되고 있는듯(?)한 플랫폼 3가지를 비교해 보았다. Jekyll Ruby 기반 vGitHub Page에 최적화되어 있음 현재 가장 대중적으로 사용하는 플랫폼 한글 레퍼런스가 제일 많음 빌드를 진행하는데 너무 오래걸림 Hexo JS(Node.js) 기반 한글 레퍼런스 꽤 있음 마크다운 문서로 만든 포스팅을 하는 방법이 간단 Git으로 포스트 버전관리 불가능(두가지 브랜치로 관리) Hugo GoLang 기반 빌드가 빠름 문서화 잘되어 있음 한글 레퍼런스가 거의 없음 ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:1:0","tags":["Blog","GitBlog","Hugo"],"title":"깃 블로그 만들기","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["Blog"],"content":"Hugo!! 너로 정했다!! 기존 네이버 블로그를 작성하면서 테마가 이쁘고 커스텀 할 수있는 요소가 많은 블로그를 만들고 싶었다. 테마가 마음에 들면서 기능이 많았으면 좋다고 생각했고 jekyll, hexo, hugo 중 빌드 속도가 제일 빠르고 Golang을 사용해 볼 수 있는 좋은 기회라는 생각이 들어 hugo를 선택하게 되었다. ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:2:0","tags":["Blog","GitBlog","Hugo"],"title":"깃 블로그 만들기","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["Blog"],"content":"기본 환경 세팅 HomeBrew 설치 터미널에 아래 코드를 입력해주면 다운로드가 완료 된다! /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" Github 회원가입 순서대로 진행해주면 가입된다! 또는 포털 사이트에서 github 입력 후 오른쪽 상단 sing-in을 누르면 위 링크와 같이 가입할 수 있다! Git Downloads 홈페이지에 방문해 운영체제에 맡게 다운받아준다! Golang 설치 필자는 install을 통해 Golang을 다운했다 pakege-version : go1.20.1.darwin-amd64.pkg ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:3:0","tags":["Blog","GitBlog","Hugo"],"title":"깃 블로그 만들기","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["Blog"],"content":"Hugo 설치 터미널에 다음과 같이 입력한다. # hugo 설치 $ brew install hugo # hugo version 확인 $ hugo version # 다음과 같이 뜨면 정상적으로 설치가 완료 된 것이다. hugo v0.110.0+extended darwin/amd64 BuildDate=unknown # 만약 brew link 에러가 발생한다면 brew에 권한을 설정해줘야함 $ sudo chown -R $(whoami) $(brew --prefix)/* ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:4:0","tags":["Blog","GitBlog","Hugo"],"title":"깃 블로그 만들기","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["Blog"],"content":"Github repository 생성 2개의 레포지토리를 만들어야한다. ex) blog, \u003cusername\u003e.github.io 내가 만든 레포지토리 blog, choiseungWoo98.github.io ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:5:0","tags":["Blog","GitBlog","Hugo"],"title":"깃 블로그 만들기","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["Blog"],"content":"Hugo로 프로젝트 생성 내가 따로 프로젝트를 만들지 않아도 hugo가 알아서 만들어 준다. 간편해..👍🏻 # hugo 프로젝트 생성 $ hugo new site blog # 생성 완료되면 출력 문구 Congratulations! Your new Hugo site is created in /Users/username/folder/blog. Just a few more steps and you're ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \"hugo new theme \u003cTHEMENAME\u003e\" command. 2. Perhaps you want to add some content. You can add single files with \"hugo new \u003cSECTIONNAME\u003e/\u003cFILENAME\u003e.\u003cFORMAT\u003e\". 3. Start the built-in live server via \"hugo server\". Visit https://gohugo.io/ for quickstart guide and full documentation. ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:6:0","tags":["Blog","GitBlog","Hugo"],"title":"깃 블로그 만들기","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["Blog"],"content":"테마 설정 테마는 직접 만들 수 있다고 한다. 하지만 저는.. 기존 공개된 테마 중 가장 마음에 드는거로 사용하려한다. 원하는 테마를 선택했다면 아까 다운받은 프로젝트에 적용시켜 주자! 필자는 LoveIt테마를 사용하였다!! 해당 사이트 이동 후 Download를 누르면 Github 페이지로 이동한다. 오른쪽 초록색 Code를 클릭 후 링크를 복사하자! # 현재 경로 확인 $ pwd # 프로젝트 경로로 이동 보통 유저 정보는 default로 설정되어 있다. 나갈때는 cd .. $ cd blog # 프로젝트 폴더에 들어왔는지 확인 $ pwd # 잘 들어왔으면 아래와 같이 출력된다. # /Users/\u003cusername\u003e/blog # git 저장소로 사용하기 위한 git 명령어 $ git init # git branch 명을 변경하려면 사용해주면 된다 나는 master가 아닌 main으로 사용하고 있다. $ git branch -M main # 아까 사용하려고 했던 테마의 깃 주소를 복사해 아래와 같이 작성해주면 테마가 다운로드 된다. # git submodule add \u003c복사한 테마 주소\u003e themes/\u003c테마 이름\u003e $ git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt # blog 폴더 내부에 있는 config.toml을 다운받은 테마에 맞게 수정해준다 # 기존에 config.toml # baseURL = 'http://example.org/' # languageCode = 'en-us' # title = 'My New Hugo Site' # cp themes/\u003c위에서 설정한 테마 이름\u003e/exampleSite/config.toml config.toml $ cp themes/LoveIt/exampleSite/config.toml config.toml 이후 config.toml을 자신의 맞게 수정하면 된다. baseURL은 반드시 수정해야함! 블로그 커스텀은 추후에 한번에 다루겠습니다! 위에서 설정한 Repository name을 baseURL에 작성 ex) baseURL = \"https://ChoiSeungWoo98.github.io/\" baseURL = \"https://\u003cusername\u003e.github.io/\" 다 설정했다면 로컬에서 테스트 해보자! $ hugo server 성공하면 아래와 같은 화면을 볼 수 있다. http://localhost:1313 접속하여 확인 에러 로그 Error: module \"LoveIt\" not found; either add it as a Hugo Module or store it in \"/Users/\".: module does not exist 해당 로그가 뜬다면 themes 폴더 내부에 LoveIt이 없다는 소리다 확인 후 config.toml에서 themes = \"폴더명\" 으로 바꿔주자! Error: module \"test\" not found; either add it as a Hugo Module or store it in \"/Users/\".: module does not exist test 폴더를 찾을 수 없다는 에러이다. 현재 LoveIt테마는 directory 주소를 설정 해주고 있다 이것을 제거해주자! config.toml 에서 아래 부분을 찾아서 제거 themes directory 主题目录 themesDir = \"../..\" PC 이미지 mobile 이미지 ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:7:0","tags":["Blog","GitBlog","Hugo"],"title":"깃 블로그 만들기","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["Blog"],"content":"Git Repository 연결 여태까지 노력해서 만든 블로그를 git이랑 연동해보자! # blog -\u003e blog 레포지토리 연결 # git remote add origin http://github.com/\u003cusername\u003e/blog.git $ git remote add origin https://github.com/choiseungwoo98/blog.git # blog/public -\u003e \u003cusername\u003e.github.io 연결 # 아래 코드를 수행하기 전에 blog 폴더에 public이 없는지 확인하자! 있으면 오류가 발생한다.... # git submodule add -b main http://github.com/\u003cusername\u003e/\u003cusername\u003e.github.io.git public $ git submodule add -b main http://github.com/min1321/min1321.github.io.git public ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:8:0","tags":["Blog","GitBlog","Hugo"],"title":"깃 블로그 만들기","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["Blog"],"content":"게시글 작성 새로운 포스트를 만드는 것도 hugo에서 수행해준다.. hugo 짱.. # 아래 명령어를 입력하면 blog/content/posts/firstPost/test.md가 생성된다. 그걸 수정해서 글을 작성하면 된다! # hugo new posts/\u003c원하는 패쓰\u003e/파일 이름.md $ hugo new posts/firstPost/test.md Content \"/Users/user/workspace/blog/content/posts/firstPost/test.md\" created # 이제 게시글을 로컬에서 확인해보자! # 로컬 서버 실행 # draft: true로 설정 되어 있을때 hugo server로 실행하면 게시물이 보이지 않는다. # 따라서 아래 명령어로 서버를 실행해준다. 혹은 그냥 false로 두면 보임 # draft는 수정 중일때 true 수정 끝나면 false로 바꾸어야 github에 올라간다.. # http://localhost:1313 접속하여 확인 $ hugo server -D ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:9:0","tags":["Blog","GitBlog","Hugo"],"title":"깃 블로그 만들기","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["Blog"],"content":"드디어 배포!!! 이제 배포만 하면 깃 블로그가 생성된다!! 배포를 진행해보자! 배포하지 않으면 여태 까지 한 작업 다 필요 없다는건 안 비밀.. # 작성한 프로젝트 빌드하기 # hugo -t \u003c여러분의 테마\u003e $ hugo -t loveit # 빌드가 완료되면 public에 파일들이 생긴다. 이 부분은 위에 submodule로 나눠서 관리 하기 때문에 # 해당 폴더로 이동 후 배포해줘야함.. $ cd public # 변경된 모든 파일 추가하기 $ git add . # 커밋 남기기! # 아래 코드로 커밋을 남기면 현재 시간 기준으로 커밋 메세지가 담김 꼭 이렇게 안해줘도 됨! $ msg=\"rebuilding site `date`\" if [ $# -eq 1 ] then msg=\"$1\" fi git commit -m \"$msg\" # 현재 폴더 상태 확인하기 $ git status # 상태 확인하고 깨끗 하다면 커밋한 파일 배포해주기! $ git push origin main # blog 폴더로 이동하기 $ cd .. # blog 변경 사항 추가. public에서 배포한 부분도 여기서 다시 추가해줌 git add . # 추가한 사항 커밋 $ msg=\"rebuilding site `date`\" if [ $# -eq 1 ] then msg=\"$1\" fi git commit -m \"$msg\" # blog 배포하기 $ git push origin main 배포가 완료 되었다면 git repository에서 build되는 과정을 확인하고 오류 없이 성공했다면 본인 블로그에 들어가서 확인 할 수 있다! 블로그 주소 확인하기 블로그 주소를 모르겠다면 1. username.github.io 레포지토리를 들어가기 2. Settings에 들어가기 3. Pages로 이동 후 4. Visit site에서 확인 할 수 있다. 보통 \"https://username.github.io/ 이러한 주소일 것이다. 드디어 내 블로그 완성!! 예쁘게 꾸미고 싶은 욕심이 많이 있기 때문에 추후에 커스텀 포스트로 찾아뵙겠습니다!! 😄 ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:10:0","tags":["Blog","GitBlog","Hugo"],"title":"깃 블로그 만들기","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["Blog"],"content":"포스트 작성 시 참고한 링크 정적 페이지 vs 동적 페이지 및 정적 페이지 비교 Hugo를 사용한 깃 블로그 만들기 ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:11:0","tags":["Blog","GitBlog","Hugo"],"title":"깃 블로그 만들기","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":null,"content":"About","date":"2023-03-02","objectID":"/about/about/","tags":null,"title":"About","uri":"/about/about/"},{"categories":null,"content":"👋Introduction 🧑🏻‍💻 아직 배울게 많은 주니어 백엔드 엔지니어입니다. 👍 사용자 중심의 서비스에 관심이 많습니다. ✏️ 많은 것을 배우기 위해 열심히 노력중입니다. ","date":"2023-03-02","objectID":"/about/about/:1:0","tags":null,"title":"About","uri":"/about/about/"},{"categories":null,"content":"⚒️Stack⚒️ BackEnd DataBase FrontEnd SVN Blog ","date":"2023-03-02","objectID":"/about/about/:2:0","tags":null,"title":"About","uri":"/about/about/"},{"categories":null,"content":"✉️Contact ","date":"2023-03-02","objectID":"/about/about/:3:0","tags":null,"title":"About","uri":"/about/about/"},{"categories":["Diary"],"content":"처음 써보는 깃 블로그 게시글 입니다. 저는 이제 현업 3개월차 주주주주주주주주주주주니어 백엔드 개발자 입니다. :) 블로그를 쓰려고 다짐한 이유는 제가 느끼는 것들과 공부한 부분을 글로 적고 제 방식대로 이해하고 공부하기 위해 블로그를 작성 하자고 다짐하였습니다. 앞으로 꾸준하고 열심히 적고 배우는 개발자가 되도록 노력하겠습니다. 절대 이 마음 변치 않고 발전하는 개발자가 될 수 있도록!! 화이팅!!!!!! ","date":"2023-03-01","objectID":"/first-posts/:0:0","tags":["Diary","Jounal"],"title":"깃 블로그를 작성하기 전 다짐","uri":"/first-posts/"}]