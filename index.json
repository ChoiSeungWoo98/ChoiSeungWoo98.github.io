[{"categories":["Java"],"content":" 커리어리라는 어플을 보다가 주니어 자바 개발자를 위한 100가지 질문을 보게 되었다. 8개월 동안 회사에서 프로젝트를 여러개 진행하면서 다양한 기술을 사용해봤다. 하지만 기초 및 이론 공부는 굉장히 소홀했었다.. 기초가 단단하지 않으면 나의 개발 스펙트럼도 짧아 질것 같아서 하나하나 정리해보려 한다. 요즘 다시 괜찮아져서 블로그도 다시 시작… 화이팅..! ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:0:0","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["Java"],"content":"둘어가기 앞서 오늘은 자바 플랫폼에 대해 알아보고자 한다. JDK, JRE, JVM은 자바 플랫폼의 3대 구성요소이다. 오늘은 JDK, JRE, JVM에 추가로 JIT까지 알아보고자 한다. 이미지를 먼저 확인 후 본격적으로 들어가보자..! JDK와 JRE 그리고 JVM ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:1:0","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["Java"],"content":"JDK(Java Development Kit : 자바 개발 키트) ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:2:0","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["Java"],"content":"1. JDK는 무엇일까? Java를 사용하기 위해 모든 기능을 갖춘 SDK(Software Development Kit) JRE를 포함한 컴파일러(javac)와 jdb, javadoc 같은 도구를 포함 즉, 프로그램을 생성하고 컴파일 할 수 있다. ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:2:1","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["Java"],"content":"2. JDK 종류 Java SE(Java Standard Edition) 표준 에디션의 자바 플랫폼, 자바 언어의 핵심 기능 제공 주요패키지 java.lang.*, java.io.*, java.util.*, java.awt.*, java.rmi.*, java.net.* Java EE(Java Enterprise Edition) Java SE에 웹 애플리케이션 서버에서 동작하는 기능을 추가한 플랫폼 즉, 서버측 개발을 하기 위해 필요(JSP, Servlet, JDBC 등 기업용 애플리케이션 개발에 필요한 다양한 플랫폼) 이 스펙에 따라 제품을 구현한 것이 WAS로 부름 Java ME(Java Micro Edition) 임베디드 기기들에서 구동되기 위한 환경을 제공하는 API를 모아둔 플랫폼 제한된 자원을 가진 휴대전화, PDA(소형 전자 기기) 등에서 Java 프로그래밍 언어를 지원하기 위해 만든 플랫폼 ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:2:2","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["Java"],"content":"3. JDK 기본 도구 javac : 자바 컴파일러(자바 소스파일 =\u003e 바이트 코드) java : javac가 만든 클래스 파일을 해석 및 실행 jdb : 자바 디버깅 툴 ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:2:3","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["Java"],"content":"JRE(Java Runtime Environment : 자바 런타임 환경) ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:3:0","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["Java"],"content":"1. JRE는 무엇일까? 자바로 만든 애플리케이션을 실행할 수 있는 런타임 환경 구축 JVM과 핵심 라이브러리 및 자바 런타임 환경에서 사용하는 프로퍼티 세팅이나 리소스 파일 제공 JDK와 달리 개발하는데 필요한 툴은 제공되지 않는다. 클래스 로더, 클래스 라이브러리를 통해 작성한 코드를 라이브러리와 결합 후 JVM에 넘겨 실행 JRE는 특별한 기능을 수행하기 보단 JVM이 원할하게 잘 작동할 수 있도록 환경에 맞춰주는 역할 ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:3:1","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["Java"],"content":"2. JRE 구성요소 JVM(Java Virtual Machine) : 자바 가상 머신으로 아래 따로 다루겠습니다. Java Class Libraries : 개발하면서 자주 사용하는 여러 유용한 기능들을 모아놓은 클래스 집합 라이브러리 Java Class Loader : JVM이 동작하다가 클래스 파일을 참조하는 순간 동적으로 읽어 JVM에 링크되고 메모리에 로딩하는 역할 ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:3:2","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["Java"],"content":"JVM(Java Virtual Machine : 자바 가상 머신) ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:4:0","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["Java"],"content":"1. JVM은 무엇일까? 자바 프로그램이 어느 기기, 운영체제 상에서도 실행될 수 있도록 만듦(WORA : 한 번 쓰고 모든 곳에서 실행한다) 메모리를 효율적으로 관리 및 최적화(Garbage Collection) JVM은 단독으로 사용이 불가, 최소 배포 단위는 JRE이다. ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:4:1","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["Java"],"content":"2. 가비지 컬렉션(Garbage Collection)? JVM이 메모리를 관리하는 프로세스 사용하지 않는 메모리를 지속적으로 찾아 제거해 효육적인 메모리 관리 가비지 컬렉션 ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:4:2","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["Java"],"content":"JIT(Just In Time Compilation) 방식 ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:5:0","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["Java"],"content":"1. JIT는 무엇일까? 프로그램을 실제 실행하는 시점에 기계어로 번역하는 컴파일 기법 ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:5:1","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["Java"],"content":"2. 컴파일 기법 컴파일 기법에는 인터프리터 방식와 컴파일러 방식로 나뉨 인터프리터 방식는 코드를 한 줄씩 중간 코드인 바이트 코드로 변환 후 실행 컴파일링 방식는 코드 실행 전, 소스 코드를 한번에 기계어로 변환 후 실행 컴파일 기법 ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:5:2","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["Java"],"content":"3. Java 컴파일 기법 자바는 컴파일러 방식을 사용한다 Java Compiler를 통해 Byte Code로 변환되고 다시 기계어로 변환된다. 이 과정이 있기 때문에 느리다 평가가 존재한다. 이러한 단점을 극복하기 위해 JIT 방식이 채택되었다. ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:5:3","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["Java"],"content":"4. JIT 방식 자주 쓸만한 코드들을 기계어로 변환 시켜놓고 저장 후 이미 변환된 기계어 코드를 재사용하는 방식 ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:5:4","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["Java"],"content":"포스트 작성 시 참고한 링크 JDK(Java Development Kit) JRE(Java Development Kit) JVM(Java Virtual Machine) JIT(Just In Time Compilation) ","date":"2023-07-21","objectID":"/differencebetweenjdkandjre/:6:0","tags":["Java-Basic","Java","JDK","JRE","JIT","JVM"],"title":"JDK와 JRE의 차이 그리고 JIT, JVM","uri":"/differencebetweenjdkandjre/"},{"categories":["WebSocket"],"content":" 일을 하던 중 프로그래스 바와 같은 작업의 완료 타이밍을 알 수 있는 방법이 있을까? 같은 고민을 하다가 WebSocket을 알게 되었고 그 과정을 글로 작성해보려고 한다. ","date":"2023-05-06","objectID":"/websocket/:0:0","tags":["WebSocket","Java","Spring-Boot","웹소켓"],"title":"Spring Boot, Websocket + STOMP 사용하기","uri":"/websocket/"},{"categories":["WebSocket"],"content":"Web Socket을 사용한 코드 ","date":"2023-05-06","objectID":"/websocket/:1:0","tags":["WebSocket","Java","Spring-Boot","웹소켓"],"title":"Spring Boot, Websocket + STOMP 사용하기","uri":"/websocket/"},{"categories":["WebSocket"],"content":"포스트 작성 시 참고한 링크 서버에서 클라이언트로 이벤트를 보내는 4가지 방법 형상관리란 - 2 SVN, GIT 차이점 ","date":"2023-05-06","objectID":"/websocket/:2:0","tags":["WebSocket","Java","Spring-Boot","웹소켓"],"title":"Spring Boot, Websocket + STOMP 사용하기","uri":"/websocket/"},{"categories":["WebSocket"],"content":" 일을 하던 중 프로그래스 바와 같은 작업의 완료 타이밍을 알 수 있는 방법이 있을까? 같은 고민을 하다가 WebSocket을 알게 되었고 그 과정을 글로 작성해보려고 한다. ","date":"2023-05-06","objectID":"/servereventtoclient/:0:0","tags":["WebSocket","Java","Spring-Boot","웹소켓"],"title":"서버에서 클라이언트로 이벤트를 보내는 4가지 방법","uri":"/servereventtoclient/"},{"categories":["WebSocket"],"content":"서버에서 클라이언트로 이벤트를 보내는 4가지 방법 ","date":"2023-05-06","objectID":"/servereventtoclient/:1:0","tags":["WebSocket","Java","Spring-Boot","웹소켓"],"title":"서버에서 클라이언트로 이벤트를 보내는 4가지 방법","uri":"/servereventtoclient/"},{"categories":["WebSocket"],"content":"1. Polling 클라이언트가 평벙한 http request를 서버로 계속 날려서 이벤트 내용을 받는 방법 가장 쉬운 방법이지만 클라이언트가 지속적으로 request를 보내야 하기 때문에 클라이언트가 많아 질 수록 서버 부담이 급증 실시간으로 정보를 응답 받는 것이 아닌 반복해서 request를 보내는 사이에 바뀐 내용을 받아오는 방식 http 오버헤드가 발생한다는 큰 단점. 하지만 일정 시간 갱신되는 서버 데이터의 경우 유용. Polling 방식 ","date":"2023-05-06","objectID":"/servereventtoclient/:1:1","tags":["WebSocket","Java","Spring-Boot","웹소켓"],"title":"서버에서 클라이언트로 이벤트를 보내는 4가지 방법","uri":"/servereventtoclient/"},{"categories":["WebSocket"],"content":"2. Long Polling 서버 측에서 접속을 열어두는 시간을 길게하는 빙식 클라이언트가 서버에 http request를 날리면 서버에서 응답해야할 이벤트가 발생하면 그 순간 응답을 하는 방식 응답을 받은 클라이언트는 바로 http request를 날려 다음 이벤트 대기 polling 방식보다 서버 부담은 줄지만 이벤트 발생 간격이 좁다면 polling이랑 다르지 않음 다수의 클라이언트에게 동시에 이벤트가 발생될 경우 클라이언트가 바로 접속을 시도하면서 서버 부담이 급증 Long Polling 방식 ","date":"2023-05-06","objectID":"/servereventtoclient/:1:2","tags":["WebSocket","Java","Spring-Boot","웹소켓"],"title":"서버에서 클라이언트로 이벤트를 보내는 4가지 방법","uri":"/servereventtoclient/"},{"categories":["WebSocket"],"content":"3. WebSocket 양방향 채널을 이용해 채팅방 처럼 양방향 통신하는 방식 기존 http요청 응답 방식은 요청한 클라이언트에 응답만 가능했지만, ws 프로토콜을 통해 웹소켓 포트에 접속해 있는 모든 클라이언트에 이벤트 응답 가능 최초 접속이 일반 http request를 통해 handshaeking 과정을 통해 이루어 지기 때문에, 기존 80, 443포트로 접속하므로 추가 방화벽을 열지 않아도 가능 http 규격인 CORS 적용이나 인증등의 과정을 기존과 동일하다는 장점 단, websocket 프로토콜을 처리하기 위한 전이중 연결과 새로운 웹소켓 서버 필요 WebSocket 방식 ","date":"2023-05-06","objectID":"/servereventtoclient/:1:3","tags":["WebSocket","Java","Spring-Boot","웹소켓"],"title":"서버에서 클라이언트로 이벤트를 보내는 4가지 방법","uri":"/servereventtoclient/"},{"categories":["WebSocket"],"content":"4. SSE(Server-Sent-Events) HTML5 표준안이며 어느정도 웹소켓의 역할을 하면서 가벼움 WebSocket과 같이 양방향이 아닌 server -\u003e client 단방향이기 때문에 서버에서 이벤트나 메시지를 client로 push 하는 작업에 유용 양방향이 아니라 요청 시 ajax로 쉽게 이용 재접속 처리 같은 대부분이 저수준 처리가 자동 지원 IE는 기본 미지원이지만, polyFill을 이용할 경우 IE를 포함한 크로스브라우징 가능 SSE(Server-Sent Event) 방식 ","date":"2023-05-06","objectID":"/servereventtoclient/:1:4","tags":["WebSocket","Java","Spring-Boot","웹소켓"],"title":"서버에서 클라이언트로 이벤트를 보내는 4가지 방법","uri":"/servereventtoclient/"},{"categories":["WebSocket"],"content":"WebSocket + Stomp를 이용하여 서버와 양방향 통신 다음 게시물은 WebSocket과 Stomp를 이용하여 서버와 양방향 통신을 하는 방법에 대해 스몰 모듈 프로젝트를 만들고자 한다. ","date":"2023-05-06","objectID":"/servereventtoclient/:2:0","tags":["WebSocket","Java","Spring-Boot","웹소켓"],"title":"서버에서 클라이언트로 이벤트를 보내는 4가지 방법","uri":"/servereventtoclient/"},{"categories":["WebSocket"],"content":"포스트 작성 시 참고한 링크 서버에서 클라이언트로 이벤트를 보내는 4가지 방법 ","date":"2023-05-06","objectID":"/servereventtoclient/:3:0","tags":["WebSocket","Java","Spring-Boot","웹소켓"],"title":"서버에서 클라이언트로 이벤트를 보내는 4가지 방법","uri":"/servereventtoclient/"},{"categories":["Docker"],"content":" Mysql을 사용하여 프로젝트를 하나 진행 중이었습니다. 해당 프로젝트가 끝나고 새로운 프로젝트를 진행하게 되었는데, 새로운 프로젝트에서는 MariaDB를 사용해야하는 상황이었고, Mysql과 MariaDB는 서로 프로토콜, 프로세스 명, 명령어 등을 쉐어하고 있다고 알려져 있어 MySql이 설치되어있는 상황에서 MariaDB를 다운하면 충돌이 발생하고 MySql을 지우고 다운받을 수 없는 상황이라 동시에 사용하기 위해 Docker로 설치해여 사용하려 합니다. ","date":"2023-03-17","objectID":"/docker%EB%9E%80/:0:0","tags":["Docker"],"title":"Docker는 뭘까?","uri":"/docker%EB%9E%80/"},{"categories":["Docker"],"content":"Docker?? 컨테이너 기반의 오픈소스 가상화 플랫폼 다양한 프로그램, 실행 환경을 컨테이너로 추상화하고 동일한 인터페이스를 제공하여 프로그램 배포 및 관리를 단순화 한다. 컨테이너 엔진으로 리눅스 커널 기능을 사용하여 운영체제 위에 컨테이너를 만들고, 데몬으로 실행된다. Linux 커널의 도커 엔진 ","date":"2023-03-17","objectID":"/docker%EB%9E%80/:1:0","tags":["Docker"],"title":"Docker는 뭘까?","uri":"/docker%EB%9E%80/"},{"categories":["Docker"],"content":"컨테이너?? 호스트 OS상에 논리적인 구획(컨테이너)을 만들고, 어플리케이션을 작동시키기 위해 필요한 라이브러리나 어플리케이션 등을 하나로 모아, 마치 별도의 서버인 것처럼 사용할 수 있게 만든 것 컨테이너는 오버헤드가 적기 때문에 가볍고 고속으로 작동하는 것이 특징입니다. ","date":"2023-03-17","objectID":"/docker%EB%9E%80/:2:0","tags":["Docker"],"title":"Docker는 뭘까?","uri":"/docker%EB%9E%80/"},{"categories":["Docker"],"content":"Docker Image?? Docker에서 image는 파일로 어플리케이션 실행에 필요한 독립적인 환경을 포함한 일종의 템플릿 소스 코드, 라이브러리, 종속성, 도구 및 응용 프로그램을 실행하는데 필요한 기타 파일을 포함하는 불변 파일 읽기 전용이며 스냅샷 이라고도 부르고 이러한 일관성은 개발자에게 안정적이고 균일한 조건에서 테스트 할 수 있도록 함. ","date":"2023-03-17","objectID":"/docker%EB%9E%80/:3:0","tags":["Docker"],"title":"Docker는 뭘까?","uri":"/docker%EB%9E%80/"},{"categories":["Docker"],"content":"Docker Install brew로 설치 virtualbox, vargrant 등 가상머신 위에 도커를 띄우는 작업 필요 compose, machine등 추가 설치 필요 서버 실행시 호스트 OS에서 서버 접근시 포트 포워딩 필요 brew cask로 설치 brew cask 는 Docker Desktop on Mac 도커를 설치해주며, docker-compose, docker-machine을 같이 설치 해줌 맥 OS에서 띄우기 때문에 가상 머신에서 포트 포워딩을 할 필요 없음 # 먼저 cask 먼저 설치 $ brew install cask # Docker Install $ brew install --cask docker 위와 같이 입력하면 docker는 정상적으로 잘 다운된다! ","date":"2023-03-17","objectID":"/docker%EB%9E%80/:4:0","tags":["Docker"],"title":"Docker는 뭘까?","uri":"/docker%EB%9E%80/"},{"categories":["Docker"],"content":"MariaDB Install # Docker Image 받기 $ docker pull mariadb # mariadb 확인 $ docker images # MariaDB 컨테이너 실행 # (1) docker run : docker image에서 container를 생성 # (2) –name maria-db : maria-db라는 이름을 가진 컨테이너 생성 # (3) -p 3307:3306 : 해당 컨테이너의 포트 forwarding에 대해 inbound는 3307로 하고, # outbound는 3306으로 설정한다. # 외부에서 접속 시 3307 포트를 사용하여 컨테이너에 정보를 전달하면, 컨테이너는 내부적으로 3306 포트를 # 사용하여 처리하고 정보를 외부로 보낸다. mySQL에서도 MariaDB와 동일하게 3306 포트를 사용하기 때문. # (4) -e : 컨테이너 내 변수 설정 # (5) MYSQL_ROOT_PASSWORD=”암호” : ROOT 암호 설정 # (6) -d mariadb : mariadb라는 이미지에서 분리하여 컨테이너 생성 # (7) --lower_case_table_names=1 : 대소문자 구분을 제거해준다. $ docker run --name mariadb -p 3307:3306 -e MYSQL_ROOT_PASSWORD=1234 -d mariadb --lower_case_table_names=1 # 실행 중인 도커 확인 $ docker ps # 도커 명령어를 통해 DB 접속 $ docker exec -it mariadb mysql -u root -p 여기까지 잘 하셨으면 이제 local에서 세팅 가능합니다. 저는 DataGrip을 통해 연결해보도록 하겠습니다. ","date":"2023-03-17","objectID":"/docker%EB%9E%80/:5:0","tags":["Docker"],"title":"Docker는 뭘까?","uri":"/docker%EB%9E%80/"},{"categories":["Docker"],"content":"DataGrip 연결 아래 순서대로 진행하면 연결 가능하다!!! ","date":"2023-03-17","objectID":"/docker%EB%9E%80/:5:1","tags":["Docker"],"title":"Docker는 뭘까?","uri":"/docker%EB%9E%80/"},{"categories":["Docker"],"content":"포스트 작성 시 참고한 링크 도커란? Docker Install MariaDB Install ","date":"2023-03-17","objectID":"/docker%EB%9E%80/:6:0","tags":["Docker"],"title":"Docker는 뭘까?","uri":"/docker%EB%9E%80/"},{"categories":["Git"],"content":" workflow는 어떤 것이 있고 어떤 방법론이 있는지 조사해보자고 마음을 먹어 작성하게되었다. ","date":"2023-03-05","objectID":"/workflow%EB%9E%80/:0:0","tags":["Git","workflow"],"title":"Workflow? 작업 방식?","uri":"/workflow%EB%9E%80/"},{"categories":["Git"],"content":"WorkFlow?? Git은 브랜치로 작업을 관리한다. 팀에서 브랜치를 어떻게 사용할 지에 대한 규칙을 Workflow라고 한다. Git에서 대표적인 Workflow는 Git flow, Github flow, Gitlab flow가 있다. ","date":"2023-03-05","objectID":"/workflow%EB%9E%80/:1:0","tags":["Git","workflow"],"title":"Workflow? 작업 방식?","uri":"/workflow%EB%9E%80/"},{"categories":["Git"],"content":"Git flow 브랜치의 역할이 명확하고 대규모 프로젝트에 적합. 2개의 메인 브랜치, 3개의 보조 브랜치로 나뉨. Main Branch master 제품으로 출시하는 브랜치 실제 배포 중이 상용 버전 develop 다음 출시 버전을 개발하는 브랜치 실제 작동 중인 버전의 다음 버전을 개발하기 위한 메인 스트림 Serve Branch feature 기능을 개발하는 브랜치 develop에서 뻗어 나와 develop으로 합쳐짐 실제 개발을 할때 가장 많이 쓰이는 브랜치 기능 별 브랜치 생성 후 개발 완료 시 develop 병합 자유로운 브랜치명, 서버에 올리지 않고 local에서 작업 release 새로운 버전을 배포하기 위한 브랜치(QA 용도) develop에서 뻗어나와 develop으로 합쳐지거나 배포 준비 완료 시 master로 합쳐짐 주로 버그를 수정하는 디버깅만 커밋 release-* 라는 이름을 사용 master에 병합했다면 develop에도 병합해 내용 일치시킴 hotfix 상용 제품에서 버그 발생 시 처리하는 브랜치 master에서 뻗어 나와 버그 수정 후 master와 develop으로 병합 버그 픽스를 위한 브랜치로 다버깅만 커밋하며, 보통 일회성 사용 작업 과정 개인 작업은 develop에서 feature 브랜치를 따서 작업한다. 개인 작업이 끝나면 develop에 병합한다. develop브랜치에서 배포 준비가 끝나면 release 브랜치로 분할한다. release 브랜치에서 디버깅하고 문제가 없으면 master와 develop 브랜치에 합친다. master브랜치를 배포한다. 만약 배포 버전에서 문제가 생겨 급하게 수정해야 하면 hotfix 브랜치를 따서 작업한다. hotfix에서 버그픽스가 끝나면 master와 develop에 합친다. Git flow ","date":"2023-03-05","objectID":"/workflow%EB%9E%80/:2:0","tags":["Git","workflow"],"title":"Workflow? 작업 방식?","uri":"/workflow%EB%9E%80/"},{"categories":["Git"],"content":"Github flow 하나의 메인 브랜치인 master 브랜치를 중점으로 운용하며 pull request을 활용한 방식 master 브랜치는 항상 최신 버전 유지 및 안정적이어야 함 브랜치의 용도가 명확하게 분류되어 있지 않아 브랜치 생성 시 브랜치 명을 명확하게 작성 일반적으로 feature 브랜치의 작업은 local 저장소가 아닌 원격 저장소에 저장 작업 과정 개인 작업은 feature 브랜치에서 작업하며 작업이 끝나면 pull request를 생성한다. pull request에서 코드 리뷰 후에 문제가 없으면 master로 병합한다. master에 병합하면 바로 배포 작업을 수행한다. (CI 자동화 권장) Github flow ","date":"2023-03-05","objectID":"/workflow%EB%9E%80/:3:0","tags":["Git","workflow"],"title":"Workflow? 작업 방식?","uri":"/workflow%EB%9E%80/"},{"categories":["Git"],"content":"Gitlab flow master, develop(production) 2개의 메인 브랜치로 관리 항상 최신 버전의 버전을 유지하지 않아도 됨 배포 버전과 개발 버전을 따로 둘 수 있다는 장점 develop 브랜치는 github flow의 develop브랜치와 같은 역할을 한다. master 브랜치는 배포 버전이다. 작업 과정 개인 개발은 feature 브랜치에서 작업하고 완료 시 merge develop 브랜치가 배포되기 적합하다고 판단되면 master브랜치로 merge한다. Gitlab flow ","date":"2023-03-05","objectID":"/workflow%EB%9E%80/:4:0","tags":["Git","workflow"],"title":"Workflow? 작업 방식?","uri":"/workflow%EB%9E%80/"},{"categories":["Git"],"content":"Centralized Workflow 단일 중앙 저장소를 사용하며 master 브랜치 하나만 사용 팀 구성원들은 중앙 저장소를 복제하여 로컬 저장소를 만들고, 변경 내용을 커밋하고 언제든 중앙 저장소와 동기화 진행 중앙 저장소의 커밋이 기준이 되므로, 변경 사항을 푸시할 때, 저장소의 커밋과 충돌난다면 Git은 푸시를 거부 이 때 중앙 저장소의 변경 내용을 가져와 자신의 변경 내용과 병합하거나 재배열하여 충돌 해결 후 푸시 작업 과정 중앙 저장소를 클론하려 로컬 저장소 생성 커밋 이력을 중앙 저장소에 푸시 다른 개발자가 중앙 저장소로 푸시할 때 최신 커밋을 반영되어 있지 않으면 푸시 거부 push 할 때는 항상 최신 커밋 이력을 포함해서 올려야함 Centralized Workflow 특징 Git에 특징인 분산 버전 관리의 이점을 사용할 수 없지만 최소한의 명령어로 협업 가능 Centralized Workflow ","date":"2023-03-05","objectID":"/workflow%EB%9E%80/:5:0","tags":["Git","workflow"],"title":"Workflow? 작업 방식?","uri":"/workflow%EB%9E%80/"},{"categories":["Git"],"content":"Feature Branch Workflow 기능 별 브랜치를 만들어 작업 하는 것 master 브랜치에 손대지 않기 때문에 다른 기능 브랜치를 얼마든지 올려도 된다. 이는 로컬 저장소 백업 역할 수행 master 브랜치는 항상 버그 프리 상태로 유지하며, 병합 시 권한을 가진 사용자가 pull request 적용 작업 과정 중앙 저장소를 클론한 로컬 저장소에 작업 브랜치 생성 작업 브랜치에서 작업 후 커밋 생성 및 원격 저장소로 푸시(브랜치와 같이) pull requst를 남겨 팀에게 작업 완료 사실을 알림 담당자가 작업 내용을 검증하고 수정이 필요하다 판단되면 해당 내역을 알려줌 해당 부분을 수정 후 푸시(pr은 다시 올리지 않아도 수정 내용이 전부 표시) 담당자가 검증 후 pr을 수용하기로 결정 되었다면 병합 진행(병함은 아무나 가능) Feature Branch Workflow 특징 브랜치를 이용하면 안전하게 새 기능을 개발 할 수 있을 뿐만 아니라, pull request를 이용해서 브랜치에 대한 팀 구성원들의 토론 참여를 이끌어냄 pull request는 코드 리뷰의 시작점 코드 리뷰를 진행하면 컨벤션을 맞출 수 있음 개발 중 막히는 부분이 pr을 통해 의견을 주고 받아 팀 구성원의 도움을 받을 수 있음. 큰 규모의 프로젝트를 관리할 때는 Gitflow Workflow를 사용해 기능 개발, 릴리스, 유지보수를 위해 좀 더 엄격한 워크플로우를 유지. Feature Branch Workflow ","date":"2023-03-05","objectID":"/workflow%EB%9E%80/:6:0","tags":["Git","workflow"],"title":"Workflow? 작업 방식?","uri":"/workflow%EB%9E%80/"},{"categories":["Git"],"content":"Forking Workflow 하나의 중앙 저장소를 이용하는 것이 아니라, 개개인마다 서로 다른 원격 저장소를 운영 자신의 원격 저장소에 푸시하고 그 내용을 공식 저장소의 프로젝트 관리자에게 풀 리퀘스트를 보냄 관리자는 공식 저장소에 푸시 권한을 주지 않고도 다른 개발자의 커밋을 수용 프로젝트와 직접 관련이 없는 제 3자뿐만 아니라, 아주 큰 규모의 분산된 팀에서도 안전하게 협업하기에 좋은 방법. 특히, 오픈소스 프로젝트에서 많이 사용하는 방식 작업 과정 공식 저장소를 fork해 나의 원격 저장소 생성 다른 개발자들은 나의 원격 저장소에 푸시 할 수 없음. fork한 원격 저장소를 clone해 작업 수행 내 원격 저장소에 push하고 작업분을 반영 할 수 있는 프로젝트 관리자에게 pr을 보냄. Forking Workflow 특징 다른 워크플로우에서는 공식 저장소에 브랜치를 푸시해서 팀 구성원들이 공유했다면, Forking Workflow에서는 나의 브랜치를 다른 참여자들이 자신의 로컬 저장소로 내려 받아 참고하고 병합 Forking Workflow ","date":"2023-03-05","objectID":"/workflow%EB%9E%80/:7:0","tags":["Git","workflow"],"title":"Workflow? 작업 방식?","uri":"/workflow%EB%9E%80/"},{"categories":["Git"],"content":"포스트 작성 시 참고한 링크 Git Workflow 다양한 Workflow centralized-workflow 이미지 feature-branch-workflow 이미지 forking-workflow ","date":"2023-03-05","objectID":"/workflow%EB%9E%80/:8:0","tags":["Git","workflow"],"title":"Workflow? 작업 방식?","uri":"/workflow%EB%9E%80/"},{"categories":["Git"],"content":" 프로그래밍을 공부 했을 시절 분기되었던 브랜치를 합치는 것 작업을 merge로 만 수행했었다. 현업에 들어오고 나서 git history가 엉망이 되어가는 것을 직접 목격하였다… 어떻게 해야 history를 잘 관리 할 수 있는지 궁금하였고 사수의 도움으로 rebase하는 것을 알게 되었다. rebase 를 알고 사용하고 있지만 merge와 rebase의 차이점을 명확하게 알고 싶어 찾아보았다. ","date":"2023-03-05","objectID":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/:0:0","tags":["Git","Merge","Rebase"],"title":"Merge와 Rebase 차이","uri":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/"},{"categories":["Git"],"content":"들어가기 앞서 merge와 rebase의 차이를 알아보기 전에 이것들은 어떤 상황에서 사용하며 사용하면 어떤 일이 일어나는지 부터 간단하게 알아보고자 한다. Git이란? 형상 관리 도구 중 하나이며 소스코드를 효과적으로 관리할 수 있게 해주는 공개 소프트웨어이다. branch란? Software 개발 시 다양한 개발자들이 동일한 프로젝트 위에서 개발, 유지보수 등의 업무를 하는 경우가 많다. 이때 하나의 프로젝트 에서 동시에 작업하게 되면 여러가지 문제가 발생한다. 이 것을 해결하기 위해 각각 완전히 독립된 브랜치 생성하여 동시에 코드 개발 및 수정 할 수 있게 도와준다. ","date":"2023-03-05","objectID":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/:1:0","tags":["Git","Merge","Rebase"],"title":"Merge와 Rebase 차이","uri":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/"},{"categories":["Git"],"content":"merge? rebase? merge는 분기된 branch를 다른 branch로 합치는 과정이고 rebase는 branch의 base를 옮긴다는 개념의 차이가 있다. ","date":"2023-03-05","objectID":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/:2:0","tags":["Git","Merge","Rebase"],"title":"Merge와 Rebase 차이","uri":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/"},{"categories":["Git"],"content":"merge와 rebase의 특징 merge 병합을 하면 합쳐진 브랜치의 커밋 메시지가 중복으로 쌓임. 커밋 순서를 변경되지 않음. 존재하는 브랜치가 변경되지 않음. 새로운 merge commit을 생성. git merge rebase 병합을 하면 브랜치의 커밋 메시지가 시간 순서대로 합침. 히스토리를 깔끔하게 유지하기 위해 사용. 분기된 브랜치를 마스터 브랜치 끝에 위치 시켜, master 브랜치를 재배치(rebase) 하는 것을 말함. 즉, rebase는 어떤 특정 브랜치의 커밋 이력을 base로 재정렬되면서 해쉬 ID가 바뀜 git rebase ","date":"2023-03-05","objectID":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/:3:0","tags":["Git","Merge","Rebase"],"title":"Merge와 Rebase 차이","uri":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/"},{"categories":["Git"],"content":"rebase를 사용하는 이유 하나의 프로젝트의 많은 개발자들이 활발하게 작업을 진행하게 되면 많은 브랜치가 생기고 master브랜치로 merge만 한다면 엄청나게 복잡한 git history를 볼 수 있을 것이다. rebase를 하여 작업 순서대로 history를 관리하고 불필요한 병합 커밋을 제거할 수 있다. merge와 rebase history 비교 ","date":"2023-03-05","objectID":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/:4:0","tags":["Git","Merge","Rebase"],"title":"Merge와 Rebase 차이","uri":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/"},{"categories":["Git"],"content":"rebase 사용 시 유의점 여러 사람이 사용하고 활발하게 커밋이 일어나는 브랜치라고 한다면, Rebase를 하는 것은 자칫 위험할 수 있습니다. 왜냐하면 파생된 브랜치에서 이미 새로운 커밋이 발생하고 작업이 기록되고 있는데 이전 기준 브랜치로 base를 변경해버리면 파생브랜치로 작업하고 있던 작업자들의 커밋 히스토리가 변경되어 버리기 때문입니다. 각 작업자들은 자신의 커밋을 다시 반영하거나 재작업을 해야 할 수도 있습니다. 따라서 혼자 작업하는 브랜치나 작업하는 사람이 적어 문제상황이 발생할 확률이 적은 경우에만 주의깊게 사용해야 합니다. ","date":"2023-03-05","objectID":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/:5:0","tags":["Git","Merge","Rebase"],"title":"Merge와 Rebase 차이","uri":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/"},{"categories":["Git"],"content":"포스트 작성 시 참고한 링크 merge와 rebase 차이 rebase 사용 시 유의사항 ","date":"2023-03-05","objectID":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/:6:0","tags":["Git","Merge","Rebase"],"title":"Merge와 Rebase 차이","uri":"/merge_%EC%99%80_rebase_%EC%B0%A8%EC%9D%B4/"},{"categories":["Git"],"content":"브랜치?? 여러 개발자들이 동시에 다양한 작업을 할 수 있게 만들어 주는 기능이 바로 브랜치(Branch) 이다. 각자 독립적인 작업 영역(저장소) 안에서 마음대로 소스코드를 변경할 수 있다. 이렇게 분리된 작업 영역에서 변경된 내용은 나중에 원래의 버전과 비교해서 하나의 새로운 버전으로 만들어 낼 수 있다. ","date":"2023-03-05","objectID":"/branch%EB%9E%80/:1:0","tags":["Git","Branch"],"title":"branch가 자세히 뭘까?","uri":"/branch%EB%9E%80/"},{"categories":["Git"],"content":"브랜치 사용법 메인 브랜치에서 자신의 작업 전용 브랜치를 만듦 각자 작업을 진행한 후, 작업이 끝난 사람은 메인 브랜치에 자신의 브랜치의 변경 사항을 적용 다른 사람의 작업에 영향을 받지 않고 독립적으로 특정 작업을 수행하고 그 결과를 하나로 모음 브랜치로 그 작업의 기록을 중간 중간에 남기게 되므로 문제가 발생했을 경우 원인이 되는 작업을 찾아내거나 그에 따른 대책을 세우기 쉬워짐 ","date":"2023-03-05","objectID":"/branch%EB%9E%80/:2:0","tags":["Git","Branch"],"title":"branch가 자세히 뭘까?","uri":"/branch%EB%9E%80/"},{"categories":["Git"],"content":"Code # 브랜치 생성 # git branch branchName $ git branch myWork-1 # 브랜치 이동 # switch 혹은 checkout 둘 다 가능 # git switch branchName $ git switch myWork-1 # 브랜치 생성 및 이동 # git checkout -b branch_name # git switch -c branch_name $ git switch -c myWork-2 # 현재 브랜치 확인 $ git branch # 브랜치 삭제 # git branch -d branchName $ git branch -d myWork-1 ","date":"2023-03-05","objectID":"/branch%EB%9E%80/:3:0","tags":["Git","Branch"],"title":"branch가 자세히 뭘까?","uri":"/branch%EB%9E%80/"},{"categories":["Git"],"content":"포스트 작성 시 참고한 링크 브랜치란? ","date":"2023-03-05","objectID":"/branch%EB%9E%80/:4:0","tags":["Git","Branch"],"title":"branch가 자세히 뭘까?","uri":"/branch%EB%9E%80/"},{"categories":["형상관리"],"content":" 현재 가장 많이 사용하고 있는 형상관리도구 git에 대해 공부를 하다가 문득 궁금한 것이 생겼다. Git은 형상관리 도구 중 하나인데 다른 형상관리도구랑 어떠한 차이가 있을까? 그래서 한번 각각의 형산관리 도구에 대해 알아보고 장단점은 무엇인지 알아보고자 한다. ","date":"2023-03-04","objectID":"/%ED%98%95%EC%83%81%EA%B4%80%EB%A6%AC%EB%9E%80/:0:0","tags":["형상관리","Git","SVN","CVS"],"title":"형상관리란 SVN? GIT?","uri":"/%ED%98%95%EC%83%81%EA%B4%80%EB%A6%AC%EB%9E%80/"},{"categories":["형상관리"],"content":"형상관리?? 소프트웨어 구성 관리(Software Configuration Management) 또는 형상관리는 소프트웨어의 변경사항을 체계적으로 추적하고 통제 하는 것 일반적으로 단순 버전관리 기반의 소프트웨어 운용을 좀 더 포괄적인 학술 분야의 형태로 넓히는 근간 소프트웨어의 소스 코드, 개발 환경, 빌드 구조 등 전반적인 환경 전반적인 내역에 대한 관리 체계를 정의 형상 관리는 포괄적인 개념, 통상적으로 버전관리, 소스관리 등으로 불립니다. 즉, 정보를 여러 버전을 관리하는 것 ","date":"2023-03-04","objectID":"/%ED%98%95%EC%83%81%EA%B4%80%EB%A6%AC%EB%9E%80/:1:0","tags":["형상관리","Git","SVN","CVS"],"title":"형상관리란 SVN? GIT?","uri":"/%ED%98%95%EC%83%81%EA%B4%80%EB%A6%AC%EB%9E%80/"},{"categories":["형상관리"],"content":"변경관리 / 버전관리 / 형상관리 변경관리, 버전관리, 형상관리. 표면적인 의미로 보면 거의 비슷하지만 이들은 제어 및 지원 범위에서 차이가 있다. 변경 관리 : 소스코드 변경 사항에 대한 관리 버전 관리 : 변경사항을 ‘버전’이란 개념을 통해 관리. 형상 관리 : 위의 개념을 포함해 프로젝트와 관련된 모든 변경사항을 관리. 포함관계를 포함하자면 변경관리 ⊆ 버전관리 ⊆ 형상관리 형상관리 3가지 버전 ","date":"2023-03-04","objectID":"/%ED%98%95%EC%83%81%EA%B4%80%EB%A6%AC%EB%9E%80/:2:0","tags":["형상관리","Git","SVN","CVS"],"title":"형상관리란 SVN? GIT?","uri":"/%ED%98%95%EC%83%81%EA%B4%80%EB%A6%AC%EB%9E%80/"},{"categories":["형상관리"],"content":"버전 관리 시스템? 형상관리 중에서 문서, 소스코드 등을 버전을 관리해주는 버전관리시스템이다. 통상적으로 “형상관리 ≒ 버전관리” 임을 인지하고 접근하는 것이 이해하기 쉽다. ","date":"2023-03-04","objectID":"/%ED%98%95%EC%83%81%EA%B4%80%EB%A6%AC%EB%9E%80/:3:0","tags":["형상관리","Git","SVN","CVS"],"title":"형상관리란 SVN? GIT?","uri":"/%ED%98%95%EC%83%81%EA%B4%80%EB%A6%AC%EB%9E%80/"},{"categories":["형상관리"],"content":"버전 관리(형상 관리)를 위한 도구와 특징 CVS(Concurrent Version System) 90년에 출시된 무료 서버-클라이언트 형상관리 시스템 파일 전체를 저장하는 것이 아니라 변경사항만을 저장 변경사항만 저장하기 때문에 용량을 적게 차지하지만 속도가 상대적으로 느림 Perforce(P4D) 빠른 속도, 빠른 Merge가 가능하며 큰 리소스 관리에 좋음 유료이고 파일명이 바뀌면 히스토리 추적이 곤란 SVN (Subversion) 형상관리/소스관리 툴의 일종 중앙관리만 지원 다른 사용자의 커밋과 엉키지 않으며, 커밋 실패 시 롤백 기능을 지원 Git 분산형 버전관리 시스템 Repository의 완전한 복사본을 로컬에 저장할 수 있음 처리속도가 빠르지만 대용량 코드 관리에 부적절 ","date":"2023-03-04","objectID":"/%ED%98%95%EC%83%81%EA%B4%80%EB%A6%AC%EB%9E%80/:4:0","tags":["형상관리","Git","SVN","CVS"],"title":"형상관리란 SVN? GIT?","uri":"/%ED%98%95%EC%83%81%EA%B4%80%EB%A6%AC%EB%9E%80/"},{"categories":["형상관리"],"content":"가장 많이 사용하는 SVN과 Git 비교 SVN (Subversion) SVN은 보통 대부분의 기능을 완성해놓고 소스를 중앙 저장소에 commit commit의 이미 자체가 중앙 저장소에 해당 기능을 공개한다는 의미. 개발자가 자신만의 version history를 가질 수 없음. commit한 내용에 실수가 있을 시에 다른 개발자에게 바로 영향을 미치게 되는 단점도 있다. 저장소를 한개만 두는 것의 단점은 만약 데이터가 소실되었을때 복구가 어려움 Git 개발자가 자신만의 commit history를 가질 수 있고, 개발자와 서버의 저장소는 독립적으로 관리가 가능. commit한 내용에 실수가 있더라도 이 바로 서버에 영향을 미치지 않음. 개발자는 commit 하다가 자신이 원하는 순간에 서버에 변경 내역(commit history)을 보낼 수 있음. 서버의 통합 관리자는 관리자가 원하는 순간에 각 개발자의 commit history를 가져올 수 있음. ","date":"2023-03-04","objectID":"/%ED%98%95%EC%83%81%EA%B4%80%EB%A6%AC%EB%9E%80/:5:0","tags":["형상관리","Git","SVN","CVS"],"title":"형상관리란 SVN? GIT?","uri":"/%ED%98%95%EC%83%81%EA%B4%80%EB%A6%AC%EB%9E%80/"},{"categories":["형상관리"],"content":"SVN과 Git 차이점 git은 로컬 저장소가 있으므로 네트워크에 접근할 필요가 없기 때문에 빠름. svn은 commit 하는 순간 저장소를 공유하는 모든 개발자들이 보게 된다. git은 내 로컬 저장소에서 마음껏 개발하고 정리하여 필요할 때 원격 저장소로 올림. git의 경우 원격 저장소 서버가 잠시 끊기더라도 버전 컨트롤이 가능 svn은 서버가 끊기는 순간 버전 컨트롤도 같이 끊김. 원격 저장소가 사라지면 svn은 복구 불가, git은 로컬 저장소에 사본을 들고 있다면 복구 가능. svn은 저장소가 하나, git은 로컬 저장소/원격 저장소로 저장소를 분산해서 관리 ","date":"2023-03-04","objectID":"/%ED%98%95%EC%83%81%EA%B4%80%EB%A6%AC%EB%9E%80/:6:0","tags":["형상관리","Git","SVN","CVS"],"title":"형상관리란 SVN? GIT?","uri":"/%ED%98%95%EC%83%81%EA%B4%80%EB%A6%AC%EB%9E%80/"},{"categories":["형상관리"],"content":"포스트 작성 시 참고한 링크 형상관리란 - 1 형상관리란 - 2 SVN, GIT 차이점 ","date":"2023-03-04","objectID":"/%ED%98%95%EC%83%81%EA%B4%80%EB%A6%AC%EB%9E%80/:7:0","tags":["형상관리","Git","SVN","CVS"],"title":"형상관리란 SVN? GIT?","uri":"/%ED%98%95%EC%83%81%EA%B4%80%EB%A6%AC%EB%9E%80/"},{"categories":["Blog"],"content":" 현업에서 일하기 시작한지 이제 3개월이 지나가고 있는 시점에 공부가 필요하다고 뼈저리게 느끼고 있습니다. 직장에 다니기 전에 네이버 블로그를 통해 배운 내용을 정리하였지만 조금 더 개발자스러운 블로그를 운영하고 싶다고 느껴 깃 블로그를 만들게 되었습니다. 시작하기 앞서 운영체제는 MAC에서 제작하였습니다. ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:0:0","tags":["Blog","GitBlog","Hugo"],"title":"깃 블로그 만드는 방법","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["Blog"],"content":"블로그 플랫폼 선택 블로그를 쓰려고 마음먹고 나서 플랫폼이 뭐가 있는지 찾아보면서 나한테 가장 잘 맞는 플랫폼은 뭐가 있을까? 많은 고민을 하던 중 가장 많이 사용되고 있는듯(?)한 플랫폼 3가지를 비교해 보았다. Jekyll Ruby 기반 vGitHub Page에 최적화되어 있음 현재 가장 대중적으로 사용하는 플랫폼 한글 레퍼런스가 제일 많음 빌드를 진행하는데 너무 오래걸림 Hexo JS(Node.js) 기반 한글 레퍼런스 꽤 있음 마크다운 문서로 만든 포스팅을 하는 방법이 간단 Git으로 포스트 버전관리 불가능(두가지 브랜치로 관리) Hugo GoLang 기반 빌드가 빠름 문서화 잘되어 있음 한글 레퍼런스가 거의 없음 ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:1:0","tags":["Blog","GitBlog","Hugo"],"title":"깃 블로그 만드는 방법","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["Blog"],"content":"Hugo!! 너로 정했다!! 기존 네이버 블로그를 작성하면서 테마가 이쁘고 커스텀 할 수있는 요소가 많은 블로그를 만들고 싶었다. 테마가 마음에 들면서 기능이 많았으면 좋다고 생각했고 jekyll, hexo, hugo 중 빌드 속도가 제일 빠르고 Golang을 사용해 볼 수 있는 좋은 기회라는 생각이 들어 hugo를 선택하게 되었다. ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:2:0","tags":["Blog","GitBlog","Hugo"],"title":"깃 블로그 만드는 방법","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["Blog"],"content":"기본 환경 세팅 HomeBrew 설치 터미널에 아래 코드를 입력해주면 다운로드가 완료 된다! /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" Github 회원가입 순서대로 진행해주면 가입된다! 또는 포털 사이트에서 github 입력 후 오른쪽 상단 sing-in을 누르면 위 링크와 같이 가입할 수 있다! Git Downloads 홈페이지에 방문해 운영체제에 맡게 다운받아준다! Golang 설치 필자는 install을 통해 Golang을 다운했다 pakege-version : go1.20.1.darwin-amd64.pkg ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:3:0","tags":["Blog","GitBlog","Hugo"],"title":"깃 블로그 만드는 방법","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["Blog"],"content":"Hugo 설치 터미널에 다음과 같이 입력한다. # hugo 설치 $ brew install hugo # hugo version 확인 $ hugo version # 다음과 같이 뜨면 정상적으로 설치가 완료 된 것이다. hugo v0.110.0+extended darwin/amd64 BuildDate=unknown # 만약 brew link 에러가 발생한다면 brew에 권한을 설정해줘야함 $ sudo chown -R $(whoami) $(brew --prefix)/* ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:4:0","tags":["Blog","GitBlog","Hugo"],"title":"깃 블로그 만드는 방법","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["Blog"],"content":"Github repository 생성 2개의 레포지토리를 만들어야한다. ex) blog, \u003cusername\u003e.github.io 내가 만든 레포지토리 blog, choiseungWoo98.github.io ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:5:0","tags":["Blog","GitBlog","Hugo"],"title":"깃 블로그 만드는 방법","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["Blog"],"content":"Hugo로 프로젝트 생성 내가 따로 프로젝트를 만들지 않아도 hugo가 알아서 만들어 준다. 간편해..👍🏻 # hugo 프로젝트 생성 $ hugo new site blog # 생성 완료되면 출력 문구 Congratulations! Your new Hugo site is created in /Users/username/folder/blog. Just a few more steps and you're ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \"hugo new theme \u003cTHEMENAME\u003e\" command. 2. Perhaps you want to add some content. You can add single files with \"hugo new \u003cSECTIONNAME\u003e/\u003cFILENAME\u003e.\u003cFORMAT\u003e\". 3. Start the built-in live server via \"hugo server\". Visit https://gohugo.io/ for quickstart guide and full documentation. ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:6:0","tags":["Blog","GitBlog","Hugo"],"title":"깃 블로그 만드는 방법","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["Blog"],"content":"테마 설정 테마는 직접 만들 수 있다고 한다. 하지만 저는.. 기존 공개된 테마 중 가장 마음에 드는거로 사용하려한다. 원하는 테마를 선택했다면 아까 다운받은 프로젝트에 적용시켜 주자! 필자는 LoveIt테마를 사용하였다!! 해당 사이트 이동 후 Download를 누르면 Github 페이지로 이동한다. 오른쪽 초록색 Code를 클릭 후 링크를 복사하자! # 현재 경로 확인 $ pwd # 프로젝트 경로로 이동 보통 유저 정보는 default로 설정되어 있다. 나갈때는 cd .. $ cd blog # 프로젝트 폴더에 들어왔는지 확인 $ pwd # 잘 들어왔으면 아래와 같이 출력된다. # /Users/\u003cusername\u003e/blog # git 저장소로 사용하기 위한 git 명령어 $ git init # git branch 명을 변경하려면 사용해주면 된다 나는 master가 아닌 main으로 사용하고 있다. $ git branch -M main # 아까 사용하려고 했던 테마의 깃 주소를 복사해 아래와 같이 작성해주면 테마가 다운로드 된다. # git submodule add \u003c복사한 테마 주소\u003e themes/\u003c테마 이름\u003e $ git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt # blog 폴더 내부에 있는 config.toml을 다운받은 테마에 맞게 수정해준다 # 기존에 config.toml # baseURL = 'http://example.org/' # languageCode = 'en-us' # title = 'My New Hugo Site' # cp themes/\u003c위에서 설정한 테마 이름\u003e/exampleSite/config.toml config.toml $ cp themes/LoveIt/exampleSite/config.toml config.toml 이후 config.toml을 자신의 맞게 수정하면 된다. baseURL은 반드시 수정해야함! 블로그 커스텀은 추후에 한번에 다루겠습니다! 위에서 설정한 Repository name을 baseURL에 작성 ex) baseURL = \"https://ChoiSeungWoo98.github.io/\" baseURL = \"https://\u003cusername\u003e.github.io/\" 다 설정했다면 로컬에서 테스트 해보자! $ hugo server 성공하면 아래와 같은 화면을 볼 수 있다. http://localhost:1313 접속하여 확인 에러 로그 Error: module \"LoveIt\" not found; either add it as a Hugo Module or store it in \"/Users/\".: module does not exist 해당 로그가 뜬다면 themes 폴더 내부에 LoveIt이 없다는 소리다 확인 후 config.toml에서 themes = \"폴더명\" 으로 바꿔주자! Error: module \"test\" not found; either add it as a Hugo Module or store it in \"/Users/\".: module does not exist test 폴더를 찾을 수 없다는 에러이다. 현재 LoveIt테마는 directory 주소를 설정 해주고 있다 이것을 제거해주자! config.toml 에서 아래 부분을 찾아서 제거 themes directory 主题目录 themesDir = \"../..\" PC 이미지 mobile 이미지 ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:7:0","tags":["Blog","GitBlog","Hugo"],"title":"깃 블로그 만드는 방법","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["Blog"],"content":"Git Repository 연결 여태까지 노력해서 만든 블로그를 git이랑 연동해보자! # blog -\u003e blog 레포지토리 연결 # git remote add origin http://github.com/\u003cusername\u003e/blog.git $ git remote add origin https://github.com/choiseungwoo98/blog.git # blog/public -\u003e \u003cusername\u003e.github.io 연결 # 아래 코드를 수행하기 전에 blog 폴더에 public이 없는지 확인하자! 있으면 오류가 발생한다.... # git submodule add -b main http://github.com/\u003cusername\u003e/\u003cusername\u003e.github.io.git public $ git submodule add -b main http://github.com/min1321/min1321.github.io.git public ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:8:0","tags":["Blog","GitBlog","Hugo"],"title":"깃 블로그 만드는 방법","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["Blog"],"content":"게시글 작성 새로운 포스트를 만드는 것도 hugo에서 수행해준다.. hugo 짱.. # 아래 명령어를 입력하면 blog/content/posts/firstPost/test.md가 생성된다. 그걸 수정해서 글을 작성하면 된다! # hugo new posts/\u003c원하는 패쓰\u003e/파일 이름.md $ hugo new posts/firstPost/test.md Content \"/Users/user/workspace/blog/content/posts/firstPost/test.md\" created # 이제 게시글을 로컬에서 확인해보자! # 로컬 서버 실행 # draft: true로 설정 되어 있을때 hugo server로 실행하면 게시물이 보이지 않는다. # 따라서 아래 명령어로 서버를 실행해준다. 혹은 그냥 false로 두면 보임 # draft는 수정 중일때 true 수정 끝나면 false로 바꾸어야 github에 올라간다.. # http://localhost:1313 접속하여 확인 # 서버를 닫기 위해서는 ctrl + c 를 입력한다. $ hugo server -D ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:9:0","tags":["Blog","GitBlog","Hugo"],"title":"깃 블로그 만드는 방법","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["Blog"],"content":"드디어 배포!!! 이제 배포만 하면 깃 블로그가 생성된다!! 배포를 진행해보자! 배포하지 않으면 여태 까지 한 작업 다 필요 없다는건 안 비밀.. # 작성한 프로젝트 빌드하기 # hugo -t \u003c여러분의 테마\u003e $ hugo -t loveit # 빌드가 완료되면 public에 파일들이 생긴다. 이 부분은 위에 submodule로 나눠서 관리 하기 때문에 # 해당 폴더로 이동 후 배포해줘야함.. $ cd public # 변경된 모든 파일 추가하기 $ git add . # 커밋 남기기! # 아래 코드로 커밋을 남기면 현재 시간 기준으로 커밋 메세지가 담김 꼭 이렇게 안해줘도 됨! $ msg=\"rebuilding site `date`\" if [ $# -eq 1 ] then msg=\"$1\" fi git commit -m \"$msg\" # 현재 폴더 상태 확인하기 $ git status # 상태 확인하고 깨끗 하다면 커밋한 파일 배포해주기! $ git push origin main # blog 폴더로 이동하기 $ cd .. # blog 변경 사항 추가. public에서 배포한 부분도 여기서 다시 추가해줌 git add . # 추가한 사항 커밋 $ msg=\"rebuilding site `date`\" if [ $# -eq 1 ] then msg=\"$1\" fi git commit -m \"$msg\" # blog 배포하기 $ git push origin main 배포가 완료 되었다면 git repository에서 build되는 과정을 확인하고 오류 없이 성공했다면 본인 블로그에 들어가서 확인 할 수 있다! 블로그 주소 확인하기 블로그 주소를 모르겠다면 1. username.github.io 레포지토리를 들어가기 2. Settings에 들어가기 3. Pages로 이동 후 4. Visit site에서 확인 할 수 있다. 보통 \"https://username.github.io/ 이러한 주소일 것이다. 드디어 내 블로그 완성!! 예쁘게 꾸미고 싶은 욕심이 많이 있기 때문에 추후에 커스텀 포스트로 찾아뵙겠습니다!! 😄 ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:10:0","tags":["Blog","GitBlog","Hugo"],"title":"깃 블로그 만드는 방법","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["Blog"],"content":"포스트 작성 시 참고한 링크 정적 페이지 vs 동적 페이지 및 정적 페이지 비교 Hugo를 사용한 깃 블로그 만들기 ","date":"2023-03-04","objectID":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/:11:0","tags":["Blog","GitBlog","Hugo"],"title":"깃 블로그 만드는 방법","uri":"/%EA%B9%83_%EB%B8%94%EB%A1%9C%EA%B7%B8_%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":null,"content":"About","date":"2023-03-02","objectID":"/about/about/","tags":null,"title":"About","uri":"/about/about/"},{"categories":null,"content":"👋Introduction 🧑🏻‍💻 아직 배울게 많은 주니어 백엔드 엔지니어입니다. 👍 사용자 중심의 서비스에 관심이 많습니다. ✏️ 많은 것을 배우기 위해 열심히 노력중입니다. ","date":"2023-03-02","objectID":"/about/about/:1:0","tags":null,"title":"About","uri":"/about/about/"},{"categories":null,"content":"⚒️Stack⚒️ BackEnd DataBase FrontEnd SVN Blog ","date":"2023-03-02","objectID":"/about/about/:2:0","tags":null,"title":"About","uri":"/about/about/"},{"categories":null,"content":"✉️Contact ","date":"2023-03-02","objectID":"/about/about/:3:0","tags":null,"title":"About","uri":"/about/about/"},{"categories":["Diary"],"content":"처음 써보는 깃 블로그 게시글 입니다. 저는 이제 현업 3개월차 주주주주주주주주주주주니어 백엔드 개발자 입니다. :) 블로그를 쓰려고 다짐한 이유는 제가 느끼는 것들과 공부한 부분을 글로 적고 제 방식대로 이해하고 공부하기 위해 블로그를 작성 하자고 다짐하였습니다. 앞으로 꾸준하고 열심히 적고 배우는 개발자가 되도록 노력하겠습니다. 절대 이 마음 변치 않고 발전하는 개발자가 될 수 있도록!! 화이팅!!!!!! ","date":"2023-03-01","objectID":"/first-posts/:0:0","tags":["Diary","Jounal"],"title":"깃 블로그를 작성하기 전 다짐","uri":"/first-posts/"}]